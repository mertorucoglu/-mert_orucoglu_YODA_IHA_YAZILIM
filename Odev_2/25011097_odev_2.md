# Git ve GitHub Nedir?
- Yazılım geliştirme sürecinde, bir projenin farklı versiyonlarını takip etmek ve yönetmek oldukça önemlidir. Versiyon kontrolü, geliştiricilere kodlarını izlemek, değişiklikleri geri almak ve işbirliği yapmak için bir çerçeve sağlar. Git gibi araçlar, bu işlemleri kolaylaştırır ve yazılım geliştirme sürecini daha verimli hale getirir. Peki, versiyon kontrolü nedir ve neden ihtiyacımız var?
### Versiyon Kontrolü Nedir?
- Versiyon kontrolü, bir yazılım projesinin farklı sürümlerini yönetmek için kullanılan bir tekniktir. Bu teknik, bir projenin gelişim sürecini izlemeyi, değişiklikleri geri almayı, paralel geliştirme ve işbirliği yapmayı sağlar.
### Versiyon Kontrolüne Neden İhtiyacımız Var?
1. **Değişiklikleri Takip Etme:** Yazılım geliştirme sürecinde birçok değişiklik yapılır. Versiyon kontrolü, bu değişiklikleri izleyerek, hangi değişikliklerin ne zaman ve kim tarafından yapıldığını belirlemeyi sağlar. Bu, geliştiricilere daha iyi bir proje tarihçesi sunar.
2. **Hata Ayıklama ve Geri Alma:** Bir hata veya istenmeyen bir değişiklik yapıldığında, versiyon kontrolü geri alma işlemi yapmayı kolaylaştırır. Her değişiklik bir commit olarak kaydedildiği için, istenmeyen değişiklikler geri alınabilir ve projenin bir önceki sürümüne dönülebilir.
3. **Paralel Geliştirme ve İşbirliği:** Bir projede birden fazla geliştirici aynı anda çalışabilir. Versiyon kontrolü, farklı geliştiricilerin aynı dosyalar üzerinde çalışmasını ve değişikliklerini uygun bir şekilde birleştirmesini sağlar. Bu, ekip üyelerinin işbirliği yapmasını kolaylaştırır ve iş çakışmalarını önler.  
### Git & GitHub Nedir?
  Git, yazdığımız projeleri, bilgisayarımızda ya da harici disklerde binbir tehlike altında değilde internet üzerinde tutmamızı ve yönetmemizi sağlayan bir versiyon kontrol sistemidir. Projenin her zaman son haline ulaşmamızı ve güncel tutmamızı sağlayan bir araçtır.
  **Git & GitHub farklı şeylerdir.**  
  **GitHub** ise projelerimizin saklandığı (depolandığı) remote sunucudur. Github’a projelerinizi ekleyebilir aynı zamanda istediğiniz public olan farklı projelere Github üzerinden erişerek projeyi bilgisayarınıza indirebilirsiniz. 

### Neden Organizasyon İçin Git Kullanmalısınız?  
Merkezi bir sürüm kontrol sisteminden Git'e geçmek, geliştirme ekibinin yazılım oluşturma şeklini değiştirir. Git, organizasyonlar için kodun geçmişini saklayan, ekiplerin aynı proje üzerinde düzenli ve güvenli şekilde çalışmasını sağlayan bir versiyon kontrol sistemidir.
Birden fazla kişinin aynı anda çalışmasına izin verir, hataları geri almayı kolaylaştırır ve kod bütünlüğünü korur.Ayrıca Git sayesinde ekip içinde iş bölümü, şeffaflık ve verimlilik artar.

Git'in sadece yazılım geliştirme için değil, birçok iş için de kolaylık sağlar.  
### Developerlar için Git  
#### Feature Dalı İş Akışı  
Git'in en büyük avantajlarından biri dallanma yetenekleridir. Merkezi sürüm kontrol sistemlerinden farklı olarak, Git dalları ucuzdur ve birleştirilmesi kolaydır. Bu, birçok Git kullanıcısı tarafından tercih edilen özellik dalı iş akışını kolaylaştırır.  
<img src="https://wac-cdn.atlassian.com/dam/jcr:39ab5e67-39a7-4cd2-9cf4-98bc89dffd9a/01%20Feature%20Branch%20Workflow.svg?cdnVersion=3036"
width=400 height=280>  
Özellik dalları, kod tabanındaki her değişiklik için izole bir ortam sağlar. Bir geliştirici, büyüklüğü ne olursa olsun bir şey üzerinde çalışmaya başlamak istediğinde yeni bir dal oluşturur. Bu, ana dalın her zaman sıkıntısız devam etmesini sağlar.

Özellik dallarını kullanmak, üretim kodunu doğrudan düzenlemekten daha güvenilir olmakla kalmaz, aynı zamanda organizasyonel faydalar da sağlar. Örneğin bir proje üzerinde çalışırken her yeni görev veya hata düzeltmesi için, main branchden ayrı, kendi özel bir branch oluşturursunuz.  
#### Distributed Development
SVN'de, her geliştirici tek bir merkezi repoya geri yönlendiren bir çalışma kopyası alır. Git ise dağıtılmış bir sürüm kontrol sistemidir. Çalışma kopyası yerine, her geliştirici kendi yerel reposunu alır ve bu repo, tüm commit geçmişini içerir.
<img src=https://wac-cdn.atlassian.com/dam/jcr:9d51f0ee-5946-4be2-886c-ff040ef8c1a1/03.svg?cdnVersion3036>  
Tam bir yerel geçmişe sahip olmak Git'i hızlı hale getirir, çünkü bu, taahhütleri oluşturmak, bir dosyanın önceki sürümlerini incelemek veya taahhütler arasında farkları karşılaştırmak için ağ bağlantısına ihtiyaç duymayacağınız anlamına gelir.

Dağıtılmış geliştirme, mühendislik ekibini ölçeklendirmeyi de kolaylaştırır. Birisi SVN'de üretim dalını bozarsa, diğer geliştiriciler sorun giderilene kadar değişikliklerini kontrol edemezler. Git ile bu tür engellemeler yoktur. Herkes kendi yerel repolarında işine devam edebilir.

Ve özellik dallarına benzer şekilde, dağıtılmış geliştirme daha güvenilir bir ortam yaratır. Bir geliştirici kendi reposunu silse bile, başka birinin reposunu kopyalayıp yeniden başlayabilir.
#### Pull requests
Github gibi birçok kaynak kodu yönetim aracı, pull request ile Git'in temel işlevselliğini geliştirir. Pull request, başka bir geliştiriciden dallarınızdan birini kendi repolarına birleştirmelerini istemenin bir yoludur. Bu, proje liderlerinin değişiklikleri takip etmesini kolaylaştırmakla kalmaz, aynı zamanda geliştiricilerin çalışmalarını kod tabanının geri kalanıyla entegre etmeden önce çalışmalarını tartışmaya açmalarını da sağlar.  
<img src=https://wac-cdn.atlassian.com/dam/jcr:ada8f4c4-22b1-486c-872b-df83484e288b/02%20Pull%20Requests.svg?cdnVersion3036
width=400 height=280>  
Pull requests, esasen bir özellik dalına eklenmiş bir yorum dizisi oldukları için son derece çok yönlüdür. Bir geliştirici zor bir sorunla karşılaştığında, pull isteği açarak ekibin diğer üyelerinden yardım isteyebilir. Alternatif olarak, kıdemsiz geliştiriciler pull request'lerini resmi bir kod incelemesi olarak değerlendirerek tüm projeyi mahvetmediklerinden emin olabilirler.  

### Daha Hızlı Sürüm Döngüsü  
Özellik dalları, dağıtılmış geliştirme, çekme istekleri daha hızlı bir sürüm döngüsüdür. Bu özellikler, geliştiricilerin daha küçük değişiklikleri daha sık paylaşmaya teşvik edildiği çevik bir iş akışını kolaylaştırır. Buna karşılık, değişiklikler, merkezi sürüm kontrol sistemlerinde yaygın olan monolitik sürümlerden daha hızlı bir şekilde aktarılabilir.  

Bekleyebileceğiniz gibi, Git sürekli entegrasyon (CI) ve sürekli teslim (CD) ortamlarıyla çok iyi çalışır.
Git’te bulunan hook adı verilen mekanizmalar sayesinde, bir repoda belirli olaylar gerçekleştiğinde otomatik olarak scripts çalıştırabilirsiniz. Bu da, deployment işlemlerini tamamen otomatikleştirmenizi sağlar.

Ayrıca, belirli branch’lerden (örneğin develop, main vb.) gelen kodları farklı sunuculara (örneğin test, staging, production) otomatik olarak oluşturabilir veya dağıtabilirsiniz.

Örneğin:Birisi develop branch’ine bir pull request merge ettiğinde, Git’i otomatik olarak en son commit’i alıp bir test sunucusuna dağıtacak şekilde ayarlayabilirsiniz.

Bu tür bir otomatik build ve dağıtım sistemini kod incelemesi süreciyle birleştirdiğinizde, kodun development → staging → production geçerken mümkün olan en yüksek güvenilirliğe sahip olmasını sağlar.
### Ürün Geliştirme İçin Git
Git’in ürün yönetimi için faydaları, pazarlama için olanlarla büyük ölçüde aynıdır. Daha sık yapılan sürümler, daha sık müşteri geri bildirimi ve bu geri bildirimlere daha hızlı yanıt verme imkânı sağlar. Geliştiriciler kodu yazabildiği sürece, müşterilere çözümü 8 hafta sonra gelecek bir sonraki sürümü beklemek yerine hemen sunabilirsiniz.  
<img src=https://wac-cdn.atlassian.com/dam/jcr:1c1cc48f-324a-4aaa-9a54-58ab93a7d219/08.svg?cdnVersion3036
width=400 height=280>  
Feature branch, öncelikler değiştiğinde de esneklik sağlar. Örneğin, bir sürüm döngüsünün yarısındayken, bir özelliği başka, zaman açısından kritik bir özelliğin lehine ertelemek istiyorsanız, bu hiç sorun olmaz. O ilk özellik, mühendislik ekibinin ona geri dönmesi için zamanı olana kadar kendi dalında bekleyebilir.

Aynı işlevsellik, yenilik projelerini, beta testlerini ve hızlı prototipleri bağımsız kod tabanları olarak yönetmeyi de kolaylaştırır.  
## Git Reposu Nedir?  
Bir Git reposu, projenizin dosyalarının ve bu dosyaların değişiklik geçmişinin tamamının saklandığı bir alanıdır. Bu sayede kodu zaman içinde takip edebilir, yönetebilir ve üzerinde collaboration yapabilirsiniz
- Bir projenin tüm dosyalarını, branchlerini, commit’lerini ve geçmişini saklar.
- Sürüm kontrolüne olanak tanır: Projenizin önceki herhangi bir durumuna geri dönebilirsiniz
- Collaborationu destekler: Birden fazla developer, birbirlerinin değişikliklerini üzerine yazmadan birlikte çalışabilir.
- Farklı bilgisayarlarda kopyalar oluşturmak için klonlanabilir  
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250710172654460719/What-is-Git-repository.webp
width=400 height=280>  

### Git Repolarının Türleri
1. Local Repository  
- Kendi bilgisayarınızda saklanır.
- İnternet bağlantısına ihtiyaç duymadan değişiklik yapmanıza, bunları commit etmenize ve proje geçmişinizi incelemenize olanak tanır
- Örnek: Projenizin içindeki .git klasörü,local repositoryi içerir.
2. Remote Repository
- GitHub, GitLab veya Bitbucket gibi bir sunucuda barındırılır.
- Birden fazla developer'ın aynı proje üzerinde collaboration yapmasını sağlar.
- Değişiklikleri local repo ile senkronize etmek için push, pull ve fetch gibi işlemleri destekler.  

### Yeni Bir Git Reposu git init ile Nasıl Başlatılır: 
Yeni bir repo oluşturmak için git init komutunu kullanıyoruz. git init, yeni bir reponun ilk kurulumu sırasında kullanılan tek seferlik bir komuttur. Bu komutu çalıştırdığında, mevcut çalışma dizininizde yeni bir .git alt dizini oluşturulur. Bu işlem ayrıca yeni bir main branch da oluşturur.
#### Mevcut bir projeyi yeni bir Git reposu ile versiyonlama
Bu örnekte, zaten var olan bir proje klasörünüz olduğunu ve bu klasör içinde bir repo oluşturmak istediğinizi varsayar. Önce proje klasörünün kök dizinine (root) geçmek için cd komutunu ardından git init komutunu yazmalıyız.  
``` bash 
cd C:\Users\KullaniciAdiniz\Documents\<projenizin ismi>  
git init  
```  
git init komutunu mevcut bir proje klasörüne yönlendirmek, yukarıda bahsedilen aynı başlatma işlemini gerçekleştirir, ancak yalnızca o proje klasörü kapsamında uygulanır.

### Repoya değişiklik kaydetme: git add ve git commit  
Git veya diğer sürüm kontrol sistemlerinde çalışırken, “kaydetme” kavramı, bir kelime işlemci veya geleneksel dosya düzenleme uygulamalarındaki kaydetme işleminden daha nüanslıdır. Geleneksel yazılımda “kaydetme”, Git terimiyle eşdeğer olarak “commit” anlamına gelir. Yani bir commit, Git’te bir “kaydetme” işlemine eşdeğerdir.

Geleneksel kaydetme, mevcut bir dosyayı üzerine yazmak veya yeni bir dosya oluşturmak gibi bir dosya sistemi işlemi olarak düşünülmelidir. Buna karşılık, Git commit işlemi, bir dosya ve klasör koleksiyonu üzerinde çalışır.  

Git ve SVN’de değişiklikleri kaydetme işlemleri de farklıdır:
- SVN commit (check-in): Merkezi bir sunucuya uzaktan push yapılır. Yani SVN commit’in tam olarak “kaydetme” işlemini gerçekleştirebilmesi için internet bağlantısı gerekir.
- Git commit: Yerel olarak yakalanır ve birikir, gerektiğinde git push -u origin main komutu ile uzak sunucuya gönderilebilir.  

Bu fark, iki sistemin mimari tasarımlarındaki temel farktan kaynaklanır:
- Git: Dağıtılmış (distributed) model → tek bir arıza noktası yok, genellikle daha dayanıklı.
- SVN: Merkezi (centralized) model → merkezi sunucuya bağımlı.  

Git’te bir projenin mevcut durumunu kaydetmek için üç temel komut birlikte kullanılır:
- git add → değişiklikleri staging alanına ekler  
- git status → değişikliklerin durumunu gösterir  
- git commit → değişiklikleri yerel repoya kaydeder

Ayrıca Git’in stash adında ek bir kaydetme mekanizması vardır.  
- Stash, commit edilmeye hazır olmayan değişiklikler için geçici bir depolama alanıdır.
- Çalışma dizini üzerinde çalışır ve çok sayıda kullanım seçeneği sunar.  

Bir Git reposu, belirli dosya veya klasörleri ignore edecek şekilde yapılandırılabilir.  
- Bu, Git’in ignore edilen içerikteki değişiklikleri kaydetmesini engeller.
- Ignore listesi yönetimi için Git’in farklı yapılandırma yöntemleri vardır

### git add
**git add** komutu, çalışma dizinindeki bir değişikliği staging area (hazırlık alanı) ekler. Bu komut, Git’e belirli bir dosyadaki güncellemeleri bir sonraki commit işlemine dahil etmek istediğinizi söyler. Ancak, **git add** komutu değişiklikleri doğrudan repoya kaydetmez değişiklikler ancak **git commit** komutu çalıştırıldığında gerçekten kayıt altına alınır.

Bu komutlarla birlikte, çalışma dizininin ve staging alanının durumunu görmek için **git status** komutunu da kullanmanız gerekir.

Örneğin index.html isimli bir html dosyası oluşturalım. Ardından terminale şu komutu yazalım:
``` bash
git status
```
git status komutu, repository’nin şuanki durumu hakkında bilgi verir. Ardından şöyle bir cevap görmelisiniz:  

<img src=https://miro.medium.com/v2/resize:fit:1100/format:webp/1*bRjPJ98XSGYSxD6JsR6_fA.jpeg
height=100>  

Untracked files yani izlenmeyen dosya demesinin ve alt satırda index.html’in kırmızı renkte görünmesinin sebebi, bu dosyanın bu projede yeni bir değişiklik olduğu ve şuan versiyon kontrolü ile izlenmemesidir. Eğer izlenmesini istiyorsak git add komutunu kullanmamızı söylüyor. Kullanımını ise şu şekilde tarif ediyor: git add <file> Yani git add yazdıktan sonra dosya ismini yazmalıyız:  
``` bash 
git add index.html
``` 
Peki şimdi ne oldu? Ne olduğunu görmek için terminale yeniden git status yazalım:  

<img src=https://miro.medium.com/v2/resize:fit:720/format:webp/1*T-v_mlzz36jfiidrIadkGQ.jpeg
height=100>  

index.html, az önce kırmızı renkte görünüyorken git add index.html komutunu yazdıktan sonra neden yeşil renge döndü? Çünkü artık dışarıda değil de bekleme alanında yani staging area’da bekliyor da ondan :)

<img src=https://miro.medium.com/v2/resize:fit:1100/format:webp/1*SFHk5tEoSg3vW2fcAAKofQ.png
width=400 height=280>  

Yukarıdaki resme bakarsak, bizim çalıştığımız alan working directory, yaptığımız değişiklikleri git add komutu ile gönderdiğimiz yer ise staging area olarak ifade ediliyor. Staging Area, aslında projemiz üzerinde yapılan bir değişikliği repository’ye kaydetmeden önceki bekleme alanı olarak ifade edilebilir. Yapılan değişiklik staging area’da bekletiliyor. Eğer bu değişikliği repository’ye kaydetmekte kararlıysak bunu commit adı verilen bir işlem ile kayıt altına almak gerekiyor.  

### Sık Kullanılan İfadeler 
``` bash 
git add <file>
```  
Bir sonraki commit için **file** içindeki tüm değişiklikleri staging alanına ekle  
``` bash 
git add <directory>
```    
Bir sonraki commit için **directory** içindeki tüm değişiklikleri staging alanına ekle.  

``` bash 
git add .
``` 
Working directory'deki tüm şeyleri stating area'ya ekler

``` bash 
git add -p
```  
Bir sonraki commit için bir dosyanın yalnızca bazı bölümlerini seçerek eklemenizi sağlayan etkileşimli bir staging oturumu başlatır. Git, değişiklikleri parça parça (chunk) gösterir ve size bir komut sorar. **y** ile parçayı staging alanına ekler, **n** ile parçayı görmezden gelir, **s** ile parçayı daha küçük parçalara böler, **e** ile parçayı manuel olarak düzenler ve **q** ile çıkış yaparsınız.” (Bu arada git ilerde bahsedeceğim ama yinede eklemek istedim git log yazıp commit geçmişine bakarken arada commit satırları bug'a giriyor eski satırlar gözükmüyor ve kod bloğuna geçmek için **q** ya basmak gerekiyor.)  
### git commit  
Eğer staging area’da bekletilen bu değişikliği repository’ye eklemeye karar verdiysek bu adımdan sonra yapmamız gereken işlem yapılan bu değişikliği commit’lemek.  
``` bash 
git commit -m "Added index.html"
```  
Yapılan değişikliğimizi repository’ye gönderme işlemine commit diyoruz ve her commit yapılan değişiklik veya düzenlemeyle ilgili bir mesaj içermeli. Bu mesajın belirli bir standardı olmamasına rağmen genel kural; commit mesajının anlaşılır, kısa ve net olması.

Terminale yeniden git status yazıp bakarsak “nothing to commit, working tree clean” yazdığını göreceğiz. Şuan commit’lenecek bir şey olmadığını söylüyor.  
### Sık Kullanılan İfadeler  
``` bash 
git commit
```  
Staging alanındaki değişiklikleri commit et. Bu işlem, bir metin editörü açarak sizden commit mesajı girmenizi ister. Mesajı girdikten sonra dosyayı kaydedip editörü kapattığınızda, değişiklikler gerçek bir commit olarak kaydedilir.  
``` bash 
git commit -a
``` 
Çalışma dizinindeki tüm değişikliklerin bir anlık görüntüsünü commit et. Bu yalnızca takip edilen dosyalardaki değişiklikleri içerir (yani geçmişte en az bir kez git add ile eklenmiş dosyalar). (Ben bunu hiç kullanmadım çok gereksiz geldi.)

``` bash 
git commit -m "commit message"
```   
Verilen commit mesajıyla hemen bir commit oluşturan kısa yol komutu. Varsayılan olarak git commit, yerel olarak yapılandırılmış metin editörünü açar ve commit mesajı girmenizi ister. -m seçeneği kullanıldığında editör açılmaz ve mesaj doğrudan komut satırında girilebilir.

Şimdi fena bir trick gösteriyorum bunu çoğu kişi bilmez ve powershell'de falan bu çalışmıyor yalnız git bash'de  
``` bash 
git add . && git commit -m "commit message"
```   
Staging area'ya ekleyip sonra commit ediyor 2 defa yazmana gerek yok.  
``` bash 
git commit -am "commit message"  
```  
Gelişmiş kullanıcılar için bir kısa yol komutu; -a ve -m seçeneklerini birleştirir. Bu kombinasyon, tüm takip edilen dosyalardaki değişiklikleri hemen commit eder ve commit mesajını komut satırından girmenizi sağlar.   

``` bash 
git commit --amend  
```  
Bu seçenek kullanıldığında son commit değiştirilir. Yeni bir commit oluşturmak yerine, staging alanındaki değişiklikler önceki commit’e eklenir. Komut, sistemde yapılandırılmış metin editörünü açar ve daha önce girilmiş commit mesajını değiştirmeniz için sizi yönlendirir. Yani son commiti siliyor.  
### Git Remote  
SVN (Subversion), geliştiriciler için bir iletişim merkezi olarak hizmet eden tek, merkezi bir repo kullanır. İş birliği, geliştiricilerin çalışma kopyaları ile merkezi repo arasında değişiklik setlerinin (changeset) aktarılması yoluyla gerçekleşir.

Bu yapı, Git’in dağıtık (distributed) iş birliği modelinden farklıdır. Git’te her geliştiricinin kendi reposu vardır; bu repo, kendi yerel geçmişi (history) ve branch yapısıyla birlikte gelir. Kullanıcılar genellikle tek bir değişiklik seti yerine bir dizi commit paylaşır. Yani, SVN’de olduğu gibi çalışma kopyasından merkezi repoya bir değişiklik seti göndermek yerine, Git’te tüm bir branchi farklı repolar arasında paylaşabilirsiniz.

git remote komutu, değişikliklerin senkronizasyonundan sorumlu daha geniş bir sistemin parçasıdır.
Bu komutla kaydedilen kayıtlar, git fetch, git push ve git pull komutlarıyla birlikte kullanılır.
Bu komutların her biri, senkronizasyon sürecinde farklı görevler üstlenir ve ayrıntıları kendi belgelerinde incelenebilir.  
git remote komutu, diğer repolarla olan bağlantıları oluşturmanızı, görüntülemenizi ve silmenizi sağlar.
Uzaktaki bağlantılar (remotes), doğrudan diğer repolara erişim sağlayan bağlantılar değil, daha çok yer imleri (bookmark) gibidir.

Gerçek zamanlı erişim sunmak yerine, bu bağlantılar uzun ve karmaşık URL’ler yerine kullanılabilecek kolay referans isimleri sağlar.

Örneğin, aşağıdaki şema sizin reponuzdan hem merkezi repoya hem de başka bir geliştiricinin reposuna iki remote bağlantıyı gösterir.
Bu bağlantılara tam URL’lerini yazmak yerine, Git komutlarında origin ve YODA gibi takma adları kullanabilirsiniz.  
<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:df13d351-6189-4f0b-94f0-21d3fcd66038/01.svg?cdnVersion3036
width=500 height=380>
</p>  

### Git remote Genel Bakış 
git remote komutu, aslında repo içindeki ./.git/config dosyasında saklanan uzak bağlantı kayıtlarını (remote entries) yönetmek için kullanılan bir arayüzdür.
Aşağıdaki komutlar, remote bağlantı listesinin mevcut durumunu görüntülemek için kullanılır:  

``` bash 
git remote  
```  
Diğer repolara olan remote bağlantılarını listeler.

``` bash 
git remote -v
```  
Yukarıdaki komutla aynı işlemi yapar, ancak her bağlantının URL’sini de gösterir  
### Git remote Yapılandırmalarını Oluşturma ve Değiştirme  

git remote komutu, bir reponun ./.git/config dosyasını düzenlemeyi kolaylaştıran bir yardımcı (helper) komut olarak da işlev görür.
Aşağıda verilen komutlar, diğer repolarla olan bağlantıları yönetmenizi sağlar.
Bu komutlar çalıştırıldığında, reponun ./.git/config dosyası güncellenir.

Aynı sonuç, ./.git/config dosyasını bir metin düzenleyici (örneğin VS Code, Nano veya Notepad) kullanarak doğrudan düzenleyerek de elde edilebilir.  
``` bash 
git remote add <name> <url>
```

Remote bir repoya yeni bir bağlantı oluştur. Bir remote ekledikten sonra, diğer Git komutlarında **url** yerine **name** kısayolunu kullanabilirsin. 
 
``` bash 
git remote rm <name>
``` 
＜name＞ adlı remote repo bağlantısını kaldır. 

``` bash 
git remote rename <old-name> <new-name>
```     
Bir remote bağlantının adını ＜old name＞’den ＜new name＞’e değiştir.  

### Remote'un Kökeni  

Bir repoyu git clone ile klonladığınızda, Git otomatik olarak origin adında bir remote bağlantı oluşturur ve bu bağlantı klonlanan repoya işaret eder.

Bu, merkezi bir reponun yerel bir kopyasını oluşturan geliştiriciler için oldukça kullanışlıdır; çünkü upstream değişiklikleri pull'lamak veya yerel commit’leri push'lamak için kolay bir yol sağlar.

İşte bu nedenle, çoğu Git tabanlı projede merkezi repo genellikle origin olarak adlandırılır. 

### Repository URL'leri  
Git, bir remote repoya (remote repository) erişmek için birçok yol destekler. Remote bir repoya erişmenin en kolay yollarından ikisi HTTP ve SSH protokolleridir.  
- HTTP, bir repoya anonim ve sadece okuma (read-only) erişim sağlamak için kolay bir yoldur.  

Örnek:
- https://github.com/kullanici/proje.git

Ancak, genellikle HTTP adresine commit push'lamak mümkün değildir (zaten anonim push’lara izin vermek istemezsiniz).
Okuma-yazma (read-write) erişim için bunun yerine SSH kullanılmalıdır:

git@github.com:kullanici/proje.git  

SSH üzerinden erişim için host makinede geçerli bir SSH hesabına ihtiyacınız olacaktır.
Bunun dışında, Git SSH ile kimlik doğrulamalı erişimi varsayılan olarak destekler.

Günümüzün güvenli ve modern üçüncü taraf barındırma çözümleri (örneğin github.com) bu tür SSH URL’lerini size sağlar. 

### Git remote Komutları  
- ADD **NAME** **URL**  

git remote add, <name> adlı bir remote bağlantı (remote) için ./.git/config dosyasına bir kayıt ekler ve bu bağlantıyı <url> adresine işaret eder. -f seçeneği (option): Remote kaydı oluşturulduktan hemen sonra git fetch komutunu çalıştırır. --tags seçeneği: Remote kaydı oluşturulduktan hemen sonra tüm etiketleri (tags) remote repodan içe aktarır.  
``` bash 
git remote add origin https://github.com/kullanici/proje.git
git remote add -f origin https://github.com/kullanici/proje.git
git remote add --tags origin https://github.com/kullanici/proje.git
```  
- RENAME **OLD** **NEW** 

git remote rename, ./.git/config dosyasını güncelleyerek **OLD** adlı remove bağlantıyı **NEW** olarak yeniden adlandırır. Bu işlem sırasında, tüm remote-tracking branch’ler ve remote bağlantıya ait yapılandırma ayarları da güncellenir.  

``` bash 
git remote rename origin upstream
```  
- REMOVE or RM (NAME)  

git remote remove, ./.git/config dosyasını güncelleyerek **NAME** adlı remove bağlantıyı siler. Bu işlem sırasında, tüm remote-tracking branch’ler ve remove bağlantıya ait yapılandırma ayarları da kaldırılır.  
``` bash 
git remote remove origin
```  
- GET-URL (NAME)  
git remote get-url, remote URL’lerini görüntüler.  

- --push seçeneği: Fetch URL’leri yerine, push URL’leri sorgulanır.
- --all seçeneği: Remote bağlantıya ait tüm URL’ler listelenir.  

``` bash 
git remote get-url origin          # origin remote’un fetch URL’sini gösterir
git remote get-url --push origin   # origin remote’un push URL’sini gösterir
git remote get-url --all origin    # origin remote’un tüm URL’lerini listeler
```   
- SHOW (NAME)  
Remote (NAME) hakkında üst düzey bilgileri görüntüler.  

``` bash 
git remote show <NAME>
```  
``` bash 
git remote show origin
```  
PRUNE (NAME)  
git remote prune (NAME), remote (NAME) reposunda artık bulunmayan yerel branch’leri siler (prune eder).
--dry-run seçeneği: Hangi branch’lerin silineceğini listeler, ancak gerçekten silmez.  
``` bash 
git remote prune origin          # origin’de olmayan yerel branch’leri siler
git remote prune --dry-run origin # hangi branch’lerin silineceğini gösterir ama silmez
```  
### Git fetch
git fetch komutu, bir remote repodan commit’leri, dosyaları ve ref’leri yerel reponuza indirir. Fetch işlemi, başkalarının üzerinde çalıştığı değişiklikleri görmek istediğinizde yaptığınız işlemdir. Bu, svn’deki update komutuna benzer; merkezi geçmişin nasıl ilerlediğini görmenizi sağlar, ancak değişiklikleri yerel reponuza zorla birleştirmez.

Git, fetch edilen içeriği mevcut yerel içerikten izole eder; yerel geliştirme çalışmalarınıza hiçbir etkisi yoktur. Fetch edilen içerik, git checkout komutu ile açıkça alınmalıdır. Bu, commit’leri yerel reponuzla entegre etmeden önce gözden geçirmenin güvenli bir yoludur.

Bir remote repodan içerik indirirken, bunu yapmak için git pull ve git fetch komutları kullanılabilir.  

- git fetch, bu iki komutun “güvenli” versiyonu olarak düşünülebilir. Remote içeriği indirir, ancak yerel reponuzun çalışma durumunu güncellemez, böylece mevcut çalışmalarınız etkilenmez. 
- git pull, daha agresif bir alternatiftir; aktif yerel branch için remote içeriği indirir ve hemen git merge çalıştırarak yeni remote içeriği için bir merge commit oluşturur. Eğer üzerinde bekleyen değişiklikleriniz varsa, bu durum çakışmalara yol açar ve merge çatışma çözüm sürecini başlatır.  

### Git Fetch Komutunu Remote Branch’lerle Nasıl Çalışıyor  

git fetch komutunun nasıl çalıştığını daha iyi anlamak için, Git’in commit’leri nasıl organize ettiğini ve sakladığını inceleyelim:  
- Git, repo içindeki ./.git/objects dizininde tüm commit’leri (hem yerel hem remote) saklar.

- Git, branch ref’leri kullanarak yerel ve remote branch commit’lerini birbirinden ayrı tutar.

- Yerel branch’lerin ref’leri ./.git/refs/heads/ dizininde saklanır.

- git branch komutu çalıştırıldığında, bu dizindeki yerel branch ref’lerinin listesi ekrana gelir.  

``` css 
* main
  feature1
  debug2
```  
- Buradaki * işareti, aktif branch’i gösteriyor.
- Diğer branch’ler, yerel olarak mevcut olan branch’lerdir ve fetch ile gelen remote commit’lerden ayrı tutulur.  

./.git/refs/heads/ dizininin içeriğini incelediğinizde, benzer bir çıktı göreceksiniz.

- Her dosya, bir yerel branch’in commit ref’ini temsil eder.

- Örneğin, main, feature-login ve bugfix/header-fix gibi branch dosyaları burada bulunur.

- Bu dosyaların içeriği, branch’in en son commit’inin hash’ini gösterir.  

Yani, git branch komutunun çıktısı ile bu dizindeki ref dosyaları birbiriyle doğrudan ilişkilidir.  

``` bash 
ls ./.git/refs/heads/
main
feature1
debug2
```   
Remote branch’ler, yerel branch’ler gibi çalışır; farkı, başkasının reposundaki commit’lere işaret etmeleridir.

- Remote branch’ler, hangi remote’a ait olduklarını göstermek için prefix ile gelir, böylece yerel branch’lerle karışmazlar.

- Yerel branch’lerde olduğu gibi, Git’in remote branch’ler için de ref’leri vardır.

- Remote branch ref’leri, ./.git/refs/remotes/ dizininde saklanır.  

Örnek: remote-repo adında bir remote’dan fetch ettikten sonra görebileceğiniz branch’ler:  
``` bash 
git branch -r
# origin/main
# origin/feature1
# origin/debug2
# remote-repo/main
# remote-repo/other-feature
```  
Bu çıktı, daha önce incelediğimiz yerel branch’leri şimdi origin/ prefix’i ile gösterir. Ayrıca, remote-repo prefix’li remote branch’leri de görebiliyoruz.

- Bir remote branch’i tıpkı yerel branch gibi checkout edebilirsiniz, ancak bu sizi detached HEAD durumuna sokar (eski bir commit’i checkout etmek gibi).

- Bu branch’ler okuma amaçlı olarak düşünülebilir.

- Remote branch’leri görmek için, git branch komutuna -r seçeneğini ekleyebilirsiniz:
``` bash 
git branch -r
```   

- Remote branch’leri, standart git checkout ve git log komutlarıyla inceleyebilirsiniz.

- Eğer remote branch’in içerdiği değişiklikleri onaylarsanız, bunları normal bir git merge ile yerel branch’e birleştirebilirsiniz.  

### Git fetch Komutları ve Seçenekleri 
``` bash
git fetch <remote>  
```
Repodaki tüm branch’leri fetch eder. Bu aynı zamanda diğer repodan gerekli tüm commit’leri ve dosyaları da indirir.  
``` bash
git fetch <remote> <branch>
```
Yukarıdaki komutla aynı işlemi yapar, fakat yalnızca belirtilen branch’i fetch eder.  

``` bash
git fetch --all
```
Tüm kayıtlı remote’ları ve onların branch’lerini fetch eden güçlü bir komut.
``` bash
git fetch --dry-run
```
--dry-run seçeneği, komutun bir demo çalıştırmasını yapar. Fetch sırasında alacağı işlemlerin örneklerini ekrana gösterir, ancak bunları uygulamaz.  

### Git push  

git push komutu, yerel repo içeriğini bir remote repoya yüklemek için kullanılır.

- Push, yerel commit’lerinizi remote repoya aktarma yöntemidir.

- Bu, git fetch komutunun tersidir:

  - git fetch → commit’leri remote’dan yerel branch’lere alır.

  - git push → commit’leri yerel branch’lerden remote branch’lere gönderir.

- Remote branch’ler, git remote komutu ile yapılandırılır.

- Push işlemi mevcut değişiklikleri üzerine yazma riski taşıyabilir; bu yüzden dikkatli olunmalıdır.  

### Git push Kullanımı  

``` bash
git push <remote> <branch>
```
Belirtilen branch, gerekli tüm commit’ler ve iç nesnelerle birlikte remote'a push edilir ve hedef repoda yeni bir yerel branch oluşturulur. Git, mevcut commit’lerin üzerine yazmanızı önlemek için, push işlemi non-fast-forward merge ile sonuçlanacaksa bu işlemi gerçekleştirmez.  

``` bash
git push <remote> --force
```
Yukarıdaki komutla aynı, ancak hızlı ileri (fast-forward) birleştirme (merge) sağlamasa bile zorla push yap. --force bayrağını yalnızca ne yaptığınızı kesin olarak bildiğiniz durumlarda kullanın. Tüm yerel dallarınızı (branches) belirtilen remote’a push eder.  
``` bash
git push <remote> --tags
```  
Bir dalı push ettiğinizde veya --all seçeneğini kullandığınızda etiketler (tags) otomatik olarak gönderilmez. --tags bayrağı, tüm yerel etiketlerinizi remote repoya gönderir. 

### Git Push Komutunu Anlamak  
Git push, genellikle yerel değişiklikleri merkezi bir repoya göndermek (publish) için kullanılır. Local bir repo değiştirildikten sonra, yapılan değişiklikleri remote ekip üyeleriyle paylaşmak için push işlemi gerçekleştirilir.  

<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:0d181327-3fb0-44ec-9ab4-d6dea0fd406f/01%20Git%20push%20discussion.svg?cdnVersion=036
width=500 height=480>
</p>  

Yukarıdaki diyagram, yerel main dalınız merkezi repo’nun main dalının önüne geçtiğinde ve git push origin main komutunu çalıştırarak değişiklikleri yayımladığınızda neler olduğunu göstermektedir. Dikkat edin, git push temelde remote repo’dan main dalını merge etmekle (birleştirmekle) aynı işlemdir.

### Git push ve syncing  
Git push, Git’in genel “syncing” sürecinde kullanılan birçok bileşenden biridir. Syncing komutları, git remote komutu ile yapılandırılan remote branch’ler üzerinde çalışır. git push bir “upload” komutu olarak düşünülebilir; buna karşın, git fetch ve git pull “download” komutları olarak düşünülebilir. Bir değişiklik seti (changeset) download veya upload yoluyla taşındıktan sonra, değişiklikleri entegre etmek için hedef repo’da bir git merge gerçekleştirilebilir.  

### Bare repolara push yapmak  

Sık kullanılan modern bir Git uygulaması, uzak bir yerde barındırılan --bare repo’nun merkezi bir origin repo olarak görev yapmasıdır. Bu origin repo genellikle Bitbucket gibi güvenilir bir üçüncü taraf hizmette barındırılır. Push işlemi remote branch yapısını değiştirdiği için, en güvenli ve yaygın yöntem --bare bayrağı ile oluşturulmuş repo’lara push yapmaktır. Bare repo’ların çalışma dizini (working directory) olmadığından, push işlemi devam eden çalışma dizini içeriğini değiştirmez. Bare repo oluşturma hakkında daha fazla bilgi için git init konusuna bakabilirsiniz.  

### Force pushing  

Git, push isteğinizin non-fast-forward merge ile sonuçlanması durumunda merkezi repo’nun geçmişini (history) ezmenizi engeller. Yani, remote geçmişiniz kendi geçmişinizden ayrıldıysa, önce remote branch’i pull yapıp yerel branch’inize merge etmeniz ve ardından tekrar push denemeniz gerekir. Bu, SVN’de değişiklik seti (changeset) commit etmeden önce svn update ile merkezi repo ile senkronize olmanızı gerektirmesiyle benzerdir.

--force bu davranışı geçersiz kılar ve remote repo’daki branch’inizi yerel branch’inizle eşler, böylece en son pull’dan bu yana oluşmuş olabilecek upstream değişiklikleri siler. Force push’u kullanmanız gereken tek durum, paylaştığınız commit’lerin tam doğru olmadığını fark edip git commit --amend veya interaktif rebase ile düzelttiğiniz durumdur. Ancak --force seçeneğini kullanmadan önce, hiçbir takım arkadaşınızın bu commit’leri pull etmediğinden tamamen emin olmalısınız.  

### Git pull  

git pull komutu, bir remote repo’dan içerik almak ve indirmek (fetch & download) ve ardından yerel repo’yu bu içerikle eşleştirmek için kullanılır. Remote upstream değişikliklerini yerel repo’ya merge etmek, Git tabanlı iş akışlarında yaygın bir işlemdir.

Aslında git pull komutu iki başka komutun birleşimidir: önce git fetch, ardından git merge. İşlemin ilk aşamasında, git pull HEAD’in gösterdiği yerel branch’e özel bir git fetch gerçekleştirir. İçerik indirildikten sonra, git pull bir merge sürecine girer. Yeni bir merge commit oluşturulur ve HEAD yeni commit’i gösterecek şekilde güncellenir. 

### Git pull Kullanımı 

git pull komutu önce git fetch çalıştırır ve belirtilen remote repo’dan içerik indirir. Ardından git merge çalıştırılarak remote içerik referansları (refs) ve branch başları (heads) yeni bir yerel merge commit’ine birleştirilir. Pull ve merge sürecini daha iyi göstermek için aşağıdaki örneği ele alalım. Bir repo’muzun main branch’i ve bir remote origin olduğunu varsayalım.    
<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:63e58c34-b273-4e48-a6b1-6e3ba4d4a0ea/01%20bubble%20diagram-01.svg?cdnVersion3036
width=500 height=480>
</p> 
Bu senaryoda, git pull yerel ve main branch’lerinin ayrıldığı noktadan itibaren tüm değişiklikleri indirir. Bu örnekte, bu nokta E’dir. git pull, ayrılmış remote commit’leri olan A-B-C’yi fetch edecektir. Ardından pull süreci, yeni ayrılmış remote commit’lerin içeriğini barındıran yeni bir yerel merge commit oluşturacaktır.  

<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:0269bb2d-eb7f-43d8-80a2-8afa88d11eea/02%20bubble%20diagram-02.svg?cdnVersion3036
width=500 height=480>
</p> 

Yukarıdaki diyagramda yeni commit H’yi görebiliriz. Bu commit, remote A-B-C commit’lerinin içeriğini barındıran ve birleştirilmiş (combined) bir log mesajına sahip yeni bir merge commit’idir. Bu örnek, git pull için kullanılan birkaç merge stratejisinden biridir. git pull komutuna --rebase seçeneği verilerek, merge commit yerine rebase merge stratejisi kullanılabilir. Bir sonraki örnek, rebase pull’un nasıl çalıştığını gösterecektir. Diyelim ki ilk diyagramımızın başlangıç noktasındayız ve git pull --rebase komutunu çalıştırdık.  

<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:d5633068-d448-4140-953e-2ab31553ce10/03%20bubble%20diagram-03-updated@2x%20kopiera.png?cdnVersion3036
 height=480>
</p>  

Bu diyagramda artık rebase pull’un yeni H commit’i oluşturmadığını görebiliriz. Bunun yerine, rebase remote commit’leri A–B–C’yi kopyalamış ve yerel commit’leri E–F–G, onların ardından yerel origin/main commit geçmişinde yer alacak şekilde yeniden yazılmış.  

### Seçenekler  
``` bash
git fetch <remote>
git merge origin/<current-branch>
```  

Belirtilen remote’un mevcut branch’in kopyasını fetch eder ve hemen ardından bunu yerel kopya ile merge eder.

Bu işlem, yukarıdaki iki komutun ard arda çalıştırılmasıyla aynıdır:  
``` bash
git pull --no-commit <remote>
```
Varsayılan kullanımına (default invocation) benzer şekilde, remote’daki içeriği fetch eder ancak yeni bir merge commit oluşturmaz.  
``` bash
git pull --rebase <remote> 
```  

Önceki pull ile aynıdır. Fakat remote branch’i yerel branch ile birleştirmek için git merge yerine git rebase kullanılır.  

``` bash
git pull --verbose 
```  
Pull işlemi sırasında ayrıntılı (verbose) çıktı verir; bu çıktı, indirilen içeriği ve merge (birleştirme) detaylarını gösterir.  

git pull’u, Git’in svn update komutunun karşılığı olarak düşünebilirsiniz. Yerel repository’nizi upstream (remote) değişikliklerle senkronize etmenin kolay bir yoludur.

Aşağıdaki diyagram, pull işleminin her adımını açıklamaktadır.  

<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:9c543e76-04df-429e-af48-43a5276d7f4f/04-06%20Git%20pull%20discussion.svg?cdnVersion3036
width=1000 height=1000>
</p>  
Başlangıçta repository’nizin güncel (senkronize) olduğunu düşünüyorsunuz, ancak git fetch işlemi, origin’deki main branch’in sizin son kontrolünüzden bu yana ilerlediğini ortaya çıkarır.
Ardından git merge, remote main’i hemen yerel main branch’inizle birleştirir.  

### Git pull ve syncing 

git pull, remote içeriği senkronize etme sorumluluğunu üstlenen birçok komuttan biridir.

- git remote komutu, senkronizasyon komutlarının hangi remote endpoint’leri kullanacağını belirtmek için kullanılır.

- git push komutu, içerikleri bir remote repo’ya yüklemek için kullanılır.

git fetch komutu ise git pull ile karıştırılabilir. İkisi de remote içeriği indirir, ancak aralarında önemli bir fark vardır:

- git fetch → “güvenli” bir seçenektir. Remote içeriği indirir, ama yerel repository’nin durumunu değiştirmez.

- git pull → “güvensiz” olarak düşünülebilir. Remote içeriği indirir ve hemen yerel repository’nin durumunu o içeriğe uyumlu hale getirmeye çalışır. Bu, istemeden yerel repository’nin çatışmalı (conflicted) bir duruma girmesine yol açabilir.  

### Rebase'yle Birlikte Pulling  
--rebase seçeneği, gereksiz merge commitlerini önleyerek commit geçmişinin lineer (düz) olmasını sağlar. Birçok geliştirici merge yapmak yerine rebase yapmayı tercih eder; çünkü bu, “Değişikliklerimi herkesin yaptığı işlerin üstüne koymak istiyorum” demek gibidir. Bu açıdan, git pull --rebase kullanmak, normal git pull’a kıyasla svn update’e çok daha benzer bir davranış sergiler. 

Aslında, --rebase seçeneği ile pull yapmak o kadar yaygın bir iş akışı haline gelmiştir ki, bunun için özel bir konfigürasyon seçeneği bile bulunmaktadır:  

``` bash
git config --global branch.autosetuprebase always
```  
Bu komutu çalıştırdıktan sonra, tüm git pull komutları git merge yerine git rebase kullanarak değişiklikleri entegre edecektir.  

### Pull Request Nedir?  
Pull request, bir Git repository’sinde bir branch’in değişikliklerini başka bir branch ile birleştirme (merge) talebidir.

Genellikle pull request’ler, birden fazla geliştiricinin farklı özellikler veya düzeltmeler üzerinde ayrı branch’lerde çalıştığı iş akışlarında kullanılır.

- Pull request, takımın önerilen değişiklikleri incelemesine ve tartışmasına olanak tanır.

- Böylece değişiklikler main branch’e merge edilmeden önce gözden geçirilmiş olur.

Pull request’ler, GitHub, GitLab, Bitbucket gibi platformlarda oluşturulabilir.

- Bu platformlarda genellikle code review araçları ve CI/CD pipeline’ları ile birlikte kullanılır.  
### Neden Pull Request Kullanıyoruz 
Pull request’ler birkaç önemli avantaj sağlar:

1. Kod İncelemesi (Code Review):

- Takım üyeleri, kodu inceleyebilir, geliştirme önerilerinde bulunabilir ve merge edilmeden önce hataları yakalayabilir.

2. İşbirliği (Collaboration):

- Pull request’ler, tartışma ve geri bildirim için bir alan sunar.

- Geliştiriciler tasarım tercihlerini tartışabilir ve değişiklikler üzerinde anlaşabilir.

3. Kod Kalitesini Sağlama (Ensuring Code Quality):

- Pull request’ler, otomatik testler ve CI/CD pipeline’ları ile entegre edilebilir.

- Böylece sadece testleri geçen kodun merge edilmesi sağlanır.

4. Değişikliklerin Takibi (Tracking Changes):

- Pull request’ler, yapılan değişikliklerin geçmişini sağlar.

- Hangi değişikliğin ne zaman ve neden yapıldığını takip etmek kolaylaşır.  

### Pull Request Nasıl Çalışıyor  

1. Feature Branch Oluşturma:

- Geliştiriciler, belirli bir özellik veya düzeltme üzerinde çalışmak için main branch (veya master) üzerinden yeni bir branch oluşturur.

2. Değişiklikleri Geliştirme ve Commit Etme:

- Kod değişiklikleri yapılır ve feature branch’e commit edilir.

3. Branch’i Remote Repository’ye Gönderme:

- Feature branch, remote repository (ör. GitHub) üzerine push edilir.

4. Pull Request Oluşturma:

- Feature branch’i, hedef branch’e (genellikle main) merge etmek için pull request oluşturulur.

5. İnceleme ve Tartışma:

- Takım üyeleri değişiklikleri inceler, önerilerde bulunur ve kod üzerinde tartışır.

6. Geri Bildirimleri Karşılama:

- Pull request’in yazarı, istenen değişiklikleri yapar ve pull request’i günceller.

7. Pull Request’i Merge Etme:

- Pull request onaylandıktan sonra, değişiklikler hedef branch’e merge edilir ve feature branch’deki güncellemeler entegre edilmiş olur.  

### Pull Request Nasıl Oluşturulur?  
GitHub’da Pull Request Oluşturma 
1. Özellik Branch’inizi (Feature Branch) GitHub’a Push Edin:
``` bash
git push origin feature-branch
```  
 2. GitHub’da Repo’nuzun Sayfasına Gidin:  
 Branch’inizi push ettiğiniz repo sayfasına gidin.  
 
 3. Pull Requests Sekmesine Tıklayın: 

 4. “New Pull Request” e tıklayın: 
 - GitHub, feature branch'i main ile karşılaştırmanı önerecektir. 'New Pull Request'e tıklayın. 
 5. Base branch ve compare branch'i seç.
 - Base branch: Merge etmek istediğin dal. Örneğin main.
 - Compare branch: Merge edilen dal. Örneğin feature-branch
 6. Değişiklikleri gözden geçir ve ayrıntıları ekle.
 - Değişiklikleri gözden geçir, pull request için bir başlık ve açıklama ekle ve ilgili bağlamı (neden, neyi değiştirdiğini açıklayan bilgileri) dahil et.
 7. Pull request’i gönder.  
 - Create Pull Request’e (Pull Request Oluştur) tıklayarak gönder. Artık ekip üyeleri pull request’ini inceleyebilir, tartışabilir ve onaylayabilir.  


 #### Mevcut bir projeyi yeni bir Git reposu ile versiyonlama
Bu örnekte, zaten var olan bir proje klasörünüz olduğunu ve bu klasör içinde bir repo oluşturmak istediğinizi varsayar. Önce proje klasörünün kök dizinine (root) geçmek için cd komutunu ardından git init komutunu yazmalıyız.  
``` bash 
cd C:\Users\KullaniciAdiniz\Documents\<projenizin ismi>  
git init  
```  
git init komutunu mevcut bir proje klasörüne yönlendirmek, yukarıda bahsedilen aynı başlatma işlemini gerçekleştirir, ancak yalnızca o proje klasörü kapsamında uygulanır.

### Mevcut Bir Git Reposunu git clone ile Nasıl Kopyalarız
Bir repoyu GitHub.com’dan yerel bilgisayarınıza veya bir codespace’e klonlayabiliriz; bu, merge çatışmalarını çözmeyi, dosya eklemeyi veya kaldırmayı ve daha büyük commit’leri göndermeyi kolaylaştırır. Bir repoyu klonladığınızda, repoyu GitHub.com’dan yerel makinenize veya bir codespace oluşturduğunuzda remote bir sanal makineye kopyalarız.

Bir repoyu klonlamak, o anda GitHub.com’da bulunan tüm repo verilerinin tam bir kopyasını indirir; bu, projenin tüm dosya ve klasörlerinin tüm sürümlerini içerir. Değişikliklerinizi GitHub.com’daki remote repoya push yapabilir, veya başkalarının değişikliklerini GitHub.com’dan pull'layabilirsiniz.

Mevcut kendi reponuzu klonlayabilir veya başka bir kişinin mevcut reposunu klonlayarak bir projeye katkıda bulunabilirsiniz

### Repository Klonlama
1. GitHub’da, ilgili reponun ana sayfasına gidin
2. Dosya listesinin üstünde, <> Code butonuna tıklayın  

<img src=https://docs.github.com/assets/cb-13128/mw-1440/images/help/repository/code-button.webp
width=400 height=280>   

3. Repo için URL’yi kopyalayın  
- Repoyu HTTPS kullanarak klonlamak için, HTTPS altında  $\text{❐}$ tıklayın.  

- Repoyu SSH anahtarı kullanarak klonlamak için, SSH’ye tıklayın, ardından  $\text{❐}$’ye tıklayın.  

- Repoyu GitHub CLI kullanarak klonlamak için, GitHub CLI’ya tıklayın, ardından  $\text{❐}$’ye tıklayın  

<img src=https://docs.github.com/assets/cb-60499/mw-1440/images/help/repository/https-url-clone-cli.webp
width=400 height=280>  

4. Git Bash'i açın
5. Mevcut çalışma dizinini, klonlanmış dizini oluşturmak istediğiniz konuma değiştirin.
6. git clone yazın ve ardından daha önce kopyaladığınız URL’yi yapıştırın.
``` bash
git clone https://github.com/<YOUR-USERNAME>/<YOUR-REPOSITORY>
```  
7. Local klonunuzu oluşturmak için Enter tuşuna basın
``` bash 
$ git clone https://github.com/<YOUR-USERNAME>/<YOUR-REPOSITORY>
> Cloning into `Spoon-Knife`...
> remote: Counting objects: 10, done.
> remote: Compressing objects: 100% (8/8), done.
> remove: Total 10 (delta 1), reused 10 (delta 1)
> Unpacking objects: 100% (10/10), done.
```  

### Git Branch  
Git branch’leri aslında yaptığın değişikliklerin bir anlık görüntüsüne (snapshot) işaret eden bir gösterge gibidir.
Yeni bir özellik eklemek veya bir hatayı düzeltmek istediğinde değişikliğin büyük mü küçük mü olduğuna bakmadan  değişikliklerini izole etmek için yeni bir branch oluşturursun.
Bu sayede hatalı kodun main branch’e merge edilmesi zorlaşır, ayrıca değişikliklerini main branch’e merge etmeden önce geçmişini temizleme ve düzenleme fırsatın olur.  
<p align="center">
<img src=https://wac-cdn.atlassian.com/dam/jcr:a905ddfd-973a-452a-a4ae-f1dd65430027/01%20Git%20branch.svg?cdnVersion3036
width=400 height=280>  
</p>  
<p align="center">
<img src=https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Zk6GM_uDQAUbdYtHPpZjZw.png
width=400 height=280>  
</p>

Yukarıdaki diyagram, bir repoda iki ayrı geliştirme hattını (branch) görselleştiriyor: biri küçük bir özellik için, diğeri ise daha uzun süreli bir özellik için. Branch’ler üzerinde geliştirme yaparak, her iki özelliği paralel olarak çalıştırmak mümkün olur ve aynı zamanda main branch’i şüpheli kodlardan uzak tutar.

Git branch’lerinin arka plandaki uygulaması, diğer versiyon kontrol sistemi modellerine göre çok daha hafif (lightweight) bir yapıya sahiptir. Dosyaları klasörden klasöre kopyalamak yerine, Git bir branch’i bir commit’e referans olarak saklar. Bu anlamda, bir branch bir commit’ler dizisinin ucu (tip) olarak temsil edilir; commit’leri barındıran bir konteyner değildir. Bir branch’in geçmişi (history), commit’ler arasındaki ilişkiler üzerinden çıkarılır.

Git branch’leri, SVN branch’leri gibi değildir. SVN’de branch’ler genellikle nadiren yapılan büyük geliştirme çabalarını yakalamak için kullanılırken, Git branch’leri günlük iş akışınızın ayrılmaz bir parçasıdır. Aşağıdaki içerik, Git’in dahili branch mimarisini daha detaylı şekilde ele alacaktır. 

### Nasıl Çalışıyor  

Bir branch, bağımsız bir geliştirme hattını temsil eder. Branch’ler, edit/stage/commit süreci için bir soyutlama (abstraction) görevi görür. Onları, yeni bir çalışma dizini (working directory), staging alanı ve proje geçmişi (project history) talep etmenin bir yolu olarak düşünebilirsin. Yeni commit’ler, mevcut branch’in geçmişine kaydedilir ve bu durum, projenin geçmişinde bir fork (çatallanma) oluşmasına yol açar.

git branch komutu, branch oluşturmanı, listelemeni, yeniden adlandırmanı ve silmeni sağlar. Ancak branch’ler arasında geçiş yapmanı veya çatallanmış geçmişi yeniden birleştirmeni sağlamaz. Bu nedenle git branch, git checkout ve git merge komutlarıyla sıkı bir şekilde entegre çalışır.  

### Yaygın Kullanımlar  
``` bash
git branch
```  
Repository’ndeki tüm branch’leri listele. Bu, git branch --list komutuyla aynı anlama gelir.  
``` bash
git branch <branch>
```  
(branch) adlı yeni bir branch oluştur. Bu, yeni branch’e geçiş (checkout) yapmaz.  
``` bash
git branch -d <branch>
```   
Belirtilen branch’i sil. Bu işlem ‘güvenlidir’ çünkü Git, branch üzerinde merge edilmemiş değişiklikler varsa silmene izin vermez.  
``` bash
git branch -D <branch>
```  
Belirtilen branch’i, merge edilmemiş değişiklikler olsa bile zorla sil. Bu komut, belirli bir geliştirme hattıyla ilişkili tüm commit’leri kalıcı olarak silmek istediğinde kullanılır.
``` bash
git branch -m <branch>
```    
Mevcut branch’in adını (branch) olarak değiştir.

``` bash
git branch -a
```  
Tüm remote branchleri listeler.  

### Branch Oluşturma  

Branch’lerin aslında sadece commit’lere işaret eden göstergeler (pointer) olduğunu anlamak önemlidir. Bir branch oluşturduğunda, Git’in yapması gereken tek şey yeni bir gösterge oluşturmak; repository’nin başka bir yönünü değiştirmez. Eğer şu şekilde bir repository ile başlıyorsan:  

<p align="center">
<img src=https://wac-cdn.atlassian.com/dam/jcr:547aa16b-4bdd-45bc-9fbc-18e795dd9df1/02%20Creating%20branches.svg?cdnVersion3036
width=400 height=280>  
</p>  

Sonra aşağıdaki komutu kullanarak bir branch oluşturursun.  

``` bash
git branch crazy-experiment 
```  
Repository geçmişi değişmeden kalır. Tek kazandığın şey, mevcut commit’e işaret eden yeni bir gösterge (pointer) olur.  

<p align="center">
<img src=https://wac-cdn.atlassian.com/dam/jcr:387f080e-19b8-43ab-a7a3-0921ffd7298a/03%20Creating%20branches.svg?cdnVersion3036
width=400 height=280>  
</p>  

Bu sadece yeni branch’i oluşturur. Ona commit eklemeye başlamak için, önce git checkout ile o branch’i seçmen ve ardından standart git add ve git commit komutlarını kullanmak gerekir.  

###  Remote Branch’ler Oluşturma  

Git branch komutu aynı zamanda remote branch’ler üzerinde de çalışır. Remote branch’ler üzerinde işlem yapabilmek için, öncelikle bir remote repo yapılandırılmalı ve local repo konfigürasyonuna eklenmelidir.  

``` bash
$ git remote add new-remote-repo https://bitbucket.com/user/repo.git
# Add remote repo to local repo config
$ git push <new-remote-repo> crazy-experiment~
# pushes the crazy-experiment branch to new-remote-repo 
```  
Bu komut, local branch crazy-experiment’in bir kopyasını (remote) isimli remote repoya push eder.  
### Branchleri Silme  

Bir branch üzerinde çalışmayı bitirdikten ve onu main code base’e merge ettikten sonra, geçmişi kaybetmeden branch’i silebilirsin
``` bash
git branch -d crazy-experiment
```  

Ancak, branch merge edilmemişse, yukarıdaki komut bir hata mesajı verecektir:  

``` bash
error: The branch 'crazy-experiment' is not fully merged. If you are sure you want to delete it, run 'git branch -D crazy-experiment'.
```   
Bu, o geliştirme hattına olan erişimi kaybetmenden korur. Eğer gerçekten branch’i silmek istiyorsan (örneğin başarısız bir deneme ise), büyük harf -D flag’ini kullanabilirsin  

``` bash
git branch -D crazy-experiment
```  

Bu komut, branch’in durumu ne olursa olsun ve herhangi bir uyarı vermeden branch’i siler.  

Önceki komutlar, branch’in local kopyasını siler. Branch hâlâ remote repolarda mevcut olabilir. Bir remote branch’i silmek için aşağıdaki komutu çalıştır.  

``` bash
git push origin --delete crazy-experiment
```  
ya da 

``` bash
git push origin :crazy-experiment 
```   

Bu, remote origin repository’ye bir silme sinyali (delete signal) gönderir ve remote crazy-experiment branch’in silinmesini sağlar.  

### Git Checkout ve Merge  

Git checkout, branch’ler arasında geçiş yapmak, yeni branch’ler oluşturmak veya dosyaların önceki sürümlerini geri getirmek için kullanılır. Bu komut, farklı özellik geliştirmeleri arasında geçiş yapmak veya projenin geçmiş durumlarını görmek için çok önemlidir.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20251004112351568127/head.webp
width=400 height=280>  
</p>  

- Attached HEAD durumunda, HEAD mevcut branch’in ucunu gösterir, bu yüzden yapılan yeni commit’ler o branch’in geçmişini günceller.
- Detached HEAD durumunda, HEAD bir branch yerine doğrudan belirli bir commit’e işaret eder, bu yüzden yapılan commit’ler otomatik olarak herhangi bir branch’e kaydedilmez.
- Attached HEAD, devam eden geliştirme için normal çalışma durumudur ve değişikliklerin güvenli bir şekilde takip edilmesini sağlar.
- Detached HEAD ise eski commit’leri incelemek veya test etmek için kullanışlıdır, ancak burada yapılan commit’ler yeni bir branch oluşturularak kaydedilmedikçe kaybolabilir.   

### git checkout’in Temel İşlevleri  

Branch Değiştirme: Branch’ler arasında geçiş yapmak istediğinde git checkout kullanırsın. Örneğin, bir feature branch’in varsa ve main branch’ten ona geçmek istiyorsan, bu komutu kullan.  

``` bash
git checkout feature-branch 
```  
Yeni Branch Oluşturma: Yeni bir branch üzerinde çalışmaya başlamak istiyorsan, -b seçeneğini kullanarak tek bir komutla hem branch oluşturabilir hem de ona geçiş yapabilirsin.  
``` bash
git checkout -b new-feature 
```   
Bu, yeni bir branch oluşturur ve otomatik olarak ona geçiş yapar. 

Dosyaları Geri Yükleme: Bir dosyada değişiklik yaptıysan ve bunları geri almak istiyorsan, dosyayı son commit’teki durumuna geri yükleyebilirsin

``` bash
git checkout -- filename 
```   
### Git Checkout Neden Kullanılır 
- Branch’ler Arasında Geçiş Yapma: git checkout, projenin farklı özellikleri veya sürümleri üzerinde çalışmak için branch’ler arasında geçiş yapmanı sağlar.  

- Dosyaları Geri Yükleme veya Eski Commit’leri Görüntüleme: Dosyaları önceki bir duruma geri döndürmene veya geçmiş değişiklikleri incelemek için eski bir commit’i checkout etmene olanak tanır.  

### Git Checkout Komutları
1. git checkout 

Kullanıcının üzerinde çalıştığı mevcut branch’i takip etmek için bir HEAD pointer tutulur. Bu kodda git checkout komutu, HEAD pointer’ın main branch’e gitmesini sağlar.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303132129949193/Screenshot-2025-03-03-132114.png>  
</p>  

2. git checkout -b feature-branch  

Aşağıdaki kodda git checkout -b 'feature-branch', feature-branch adında yeni bir branch oluşturur ve ardından otomatik olarak o branch’e geçiş yapar.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303132346466564/Screenshot-2025-03-03-132333.png>  
</p> 

3. Belirli Bir Commit’i Checkout Etme 

git commit komutu yazıldığı anda, kod kullanıcı tarafından oluşturulan repository’ye eklenir ve kodun mevcut durumu kaydedilir. git checkout 'branch’in hash kodu' komutu ise HEAD’i o branch’ten ayırır (detached HEAD) ve artık HEAD yeni bir branch’i işaret edebilir.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303133016514728/Screenshot-2025-03-03-132934.png>  
</p>  

4. Belirli Bir Dosyayı Son Commit Edilmiş Sürümüne Geri Yükleme 

git commit komutu kullanıldığı anda, kod repository’ye eklenir. Eğer kullanıcı, kodun önceki sürümünü geri getirmek isterse, git checkout -- (dosya_adı) komutu kullanılır. Bunu bir çocuk örneğiyle düşünebiliriz: Diyelim ki adı A olan bir çocuk vardı, o zaman 10 yaşındaydı ve commit işleminden sonra 15 yaşına geldi. Eğer onun eski yaşı olan 10’u geri getirmek istiyorsam, işte bu komut kullanılır.  
<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303143856589280/Screenshot-2025-03-03-143547.png>  
</p>

5. Çalışma Dizindeki Tüm Değişiklikleri İptal Etme 

Mevcut çalışma dizininde henüz commit edilmemiş veya staging alanında olan bazı dosyalar olabilir. Bu dosyaların eski sürümlerini geri yüklemek ve commit edilmelerini durdurmak için git checkout . komutu kullanılır. 

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303144211316659/Screenshot-2025-03-03-144157.png>  
</p>  

### Git Merge 

Git merge, bir branch’te yapılan değişiklikleri başka bir branch’e entegre etmek için kullanılır. Bu komut, güncellemeleri birleştirir; böylece farklı katkıda bulunanlar tarafından yapılan veya paralel branch’lerde geliştirilen çalışmalar sorunsuz bir şekilde birleşir.  

### Git Merge'in Çalışma Süreci 

- Bir branch’teki değişiklikleri başka bir branch’e birleştirir.
- Eğer her iki branch’te de yeni değişiklikler varsa, Git bunları birleştirmek için özel bir commit oluşturur.
- Mevcut branch’te yeni commit yoksa, Git yalnızca branch pointer’ını ilerletir.
- Her iki branch’te de aynı dosya değiştirilmişse, Git manuel çatışma çözümü gerektirir.
- Rebase’in aksine, merge işlemi her iki branch’in commit geçmişini korur.  

### Neden Git Merge Kullanıyoruz  

- Değişiklikleri birleştirmek için: Git merge, bir branch’teki değişiklikleri başka bir branch’e taşımaya yardımcı olur.
- Geçmişi temiz tutmak için: Tüm önceki commit’leri korur, böylece değişiklikleri takip etmek kolay olur  

### Git Merge Komutları  

1. Basic Merge  

İlk adımda, git checkout komutu kullanılarak bir branch’e geçilir. Daha sonra, checkout yapılan branch’in durumunu alacak branch’in adıyla git merge komutu yazılır. Ardından, mevcut branch, merge edildiği branch’in güncel durumunu alır.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303150118593300/Screenshot-2025-03-03-150004.png>  
</p>  

git log --oneline --graph --decorate --all (Bu komut, branch’inizin main branch’e merge edilip edilmediğini kontrol etmek için)  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303150159630834/Screenshot-2025-03-03-150031.png>  
</p>  

2. Fast-Forward Merge   

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20230516192653/git-farwad-merging.png
width=400 height=200 >  
</p>

Önce bir commit A yapılır ve ardından içeriği olan bir dosya B oluşturulur. Commit A’da değişiklik olmadığı için, dosya B oluşturulduktan sonra A ile B’yi merge etmeye çalışırsak, sadece HEAD veya branch pointer dosya B’ye taşınır ve yeni bir merge commit’i oluşturulmaz.  

``` bash
git checkout A
git merge B 
```  
<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303150947737828/Screenshot-2025-03-03-150928.png>  
</p>  

Eski merge’in fast-forward merge olup olmadığını kontrol etmek için git reflog komutunu yazın. Eğer fast-forward merge ise, branch pointer ileriye hareket etmiş olmalı ve herhangi bir merge mesajı yazdırılmamıştır.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303151327303189/Screenshot-2025-03-03-151039.png>  
</p>  

3. Three-way merging

Bu tür, bir branch oluşturulduktan sonra temel branch değiştiğinde meydana gelir. Git, her iki branch’teki değişiklikleri temel branch ile karşılaştırarak yeni bir merge commit oluşturur.”

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20230516192737/git-three-way-merging.png
width=400 height=200>  
</p>

Not: Git, recursive ve octopus merge gibi başka merge türlerini de destekler. Tek bir merge commit ile, 'octopus merge' birden fazla branch’i aynı anda birleştirebilir. 'Recursive merge' ise üç yönlü merge’e (three-way merge) benzer, ancak üç yönlü merge’den daha karmaşık merge işlemlerini yönetebilir.

4. Commit Mesajı ile Merge Etme  

Özel bir commit mesajı ile merge eder ve ardından git show HEAD komutunu kullanarak en son commit detaylarını doğrular.  

``` bash
git merge -m 'message'
git show HEAD
```
<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303151747928502/Screenshot-2025-03-03-151734.png>  
</p>  

  5. Çatışmaları Manuel Çözerek Merge Etme  

  Bu kodda önce git checkout main komutunu kullanarak main branch’ine geçtim ve ardından git merge pranjal komutunu kullanarak pranjal branch’ini main branch’ine merge ettim.  

``` bash
git merge branchname
git status
```  
<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303152153609841/Screenshot-2025-03-03-152138.png>  
</p>  

6. Merge Edip Commit’leri Tek Bir Commit’te Toplama (Squash)  

Git squash, dağınık oyuncaklarını tek bir düzgün kutuya koymak gibidir, hepsini etrafa saçmak yerine. Birkaç küçük değişikliği alır ve hepsini tek, büyük ve temiz bir değişiklik hâline getirir!

``` bash
git merge --squash 'branchname'
```  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250303152617051138/Screenshot-2025-03-03-152606.png>  
</p>  

### Git Merge İşlemini Gerçekleştirme Adımları 

Adım 1: Yeni Bir Branch Oluştur  

``` bash
git branch <new-branch-name>
```  

Adım 2: En Son Değişiklikleri Pulla 

Merge etmeden önce, her iki branch’ten (örneğin main ve feature branch) en son değişiklikleri çektiğinizden emin ol. 

``` bash
git checkout <target-branch>    
git pull origin <target-branch>  

git checkout <feature-branch>   
git pull origin <feature-branch> 
```  

Adım 3: Branch'i Merge'le 

Herhangi bir çatışma oluşursa, Git sizi bilgilendirir. Devam etmeden önce bunları manuel olarak çözün  
``` bash
git checkout <target-branch>   
git merge <feature-branch> 
```  
<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20240611112433/git-merge-dev.webp
width=400 height=200>  
</p>   
Adım 4: Merged Code'U Test Etme  

Merge edilen kodun düzgün çalıştığından emin olmak için onu otomatik veya manuel olarak test edin.  

``` bash
# Run tests or manually test your application 
``` 

Adım 5: Merged Code' u Commit'leme  

``` bash
git commit -m "Merge branch 'dev' into main"
``` 

Adım 6: Merge Edilen Branch’i Push Etme  

``` bash
git push origin main
```  

### Git Merge vs Rebase  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250728125048930532/git_merge_vs_rebase.webp
width=400 height=200>  
</p>  

| Git Merge | Git Rebase | |
| :--- | :----: | ----: |
| Bir branch’teki değişiklikleri merge commit ile başka bir branch’e birleştirir | Bir branch’teki commit’leri başka bir branch üzerine uygular ve history’yi yeniden yazar |
| Tüm commit geçmişini korur. | Merge commit’lerini kaldırarak lineer bir history oluşturur. |
| Feature branch’lerini birleştirmek için kullanışlıdır | Temiz ve sade bir proje history’si için idealdir |
| Mevcut Commit'leri değiştirmez | Commit hash’lerini ve sırasını yeniden yazar. |  

### Git Rebase  

Git Rebase, bir branch’teki değişiklikleri başka bir branch’e entegre etmek için kullanılan bir Git komutudur; commit’lerinizi hedef branch’in en güncel noktasına (tip) taşır. Git merge’in aksine, merge yeni bir merge commit’i oluşturur ve commit history’sini bir dallanma ağacı olarak korurken, rebase commit history’nizi yeniden yazar ve çalışmalarınızın hedef branch’in en güncel değişikliklerinden başlamış gibi görünmesini sağlar.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20230517114846/git-rebase-useage.png
width=400 height=200>  
</p>  

#### Syntax 

``` bash
git checkout <feature-branch>
git rebase <base-branch>
```  

Bu syntax'de:

- (feature-branch): Rebase yapmak istediğiniz değişiklikleri içeren branch.

- (base-branch): Değişikliklerinizi üzerine rebase yapmak istediğiniz branch; genellikle main veya master olur.  

### Git Rebase Ne Zaman Kullanılır  

Diyelim ki bir feature üzerinde çalışıyorsunuz (örneğin “login butonu eklemek”) ve aynı anda takım arkadaşınız main projeye başka bir şey ekliyor (örneğin “bir bug’ı düzeltmek”). Daha sonra, işinizi tamamlamadan önce main projedeki en güncel değişiklikleri işinize dahil etmek istiyorsunuz.  

Şunu şöyle düşünebiliriz:
- Bir rapor için bir paragraf yazıyorsunuz.
- Siz yazarken, başka biri rapora yeni satırlar ekliyor.
- git rebase, paragrafınızı raporun en güncel sürümünün sonuna taşımanıza olanak tanır; böylece sanki bu yeni satırlardan sonra yazmışsınız gibi görünür.  

#### Örnek 
1. Siz ve takım arkadaşınız şununla başlıyorsunuz:  

``` bash
A → B   (main branch)
```  

2. Feature branch’inizi oluşturuyorsunuz ve bazı değişiklikler yapıyorsunuz: 

``` bash
A → B   (main)
          \
           C → D   (feature)
```  
3. Bu arada, takım arkadaşınız main branch’i güncelliyor: 

``` bash
A → B → E → F   (main)
          \
           C → D     (your branch is outdated now)
```  

4. Şimdi şunu çalıştırıyoruz: 

``` bash
git checkout feature
git rebase main
```  

5. Feature branch’iniz taşındı ve şimdi şöyle görünüyor: 
``` bash
A → B → E → F → C' → D'  (rebased feature branch)
```  
Sizin çalışmalarınız (C ve D), artık en son yapılan çalışmaların (E ve F) sonrasına yerleştirildi. Kod history’si temiz ve takip etmesi kolay.  

### Rebase Sırasında Ne Oluyor?  

- Git önce değişikliklerinizi geçici olarak kaldırır.
- Sonra, rebase yaptığınız branch’teki en güncel çalışmaları ekler.
- Ardından, kendi değişikliklerinizi bunun üzerine yeniden uygular.
- Böylece değişikliklerinizin yeni commit versiyonlarını oluşturur (C′ ve D′ olarak adlandırılır).  


Git Rebase’in Görsel Çalışma Mantığı:  


<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20250305094419023965/Rebasing-in-git.png
width=400 height=200>  
</p>  

#### Rebasing'den Önce 

``` bash
C1 → C2 → C3 → C4 → C5   (Main Branch)
        \
         B1 → B2 → B3     (Feature Branch)
```  

- C1’den C5’e kadar commit’ler main branch’te (yeşil).
- B1’den B3’e kadar commit’ler feature branch’te (sarı), C3’ten türetilmiş.
- Bu noktada feature branch güncel değil, çünkü main branch ilerlemiş (C4 ve C5, C3’ten sonra eklenmiş). 

#### B1, B2 ve B3 rebase edildikten sonra  

``` bash
C1 → C2 → C3 → C4 → C5 → C6 → C7 → C8
                                ↑
                             (Rebased Feature Commits)
``` 

- git rebase komutu, B1 → B2 → B3 commit’lerini alır ve bunları main branch’teki en son commit olan C5’in üzerine yeniden uygular.
- Bunlar yeni commit’ler haline gelir: C6 → C7 → C8 (B1–B3’ün yeşil versiyonları).
- Feature branch artık sanki main branch’in en güncel sürümüne dayanıyormuş gibi görünür  

### Git Rebase Arka Tarafta Ne Yapıyor 

1. Temeli buldu: Git, main ve feature branch’ler arasındaki ortak atayı (C3) buldu.
2. B1, B2 ve B3 commit’lerini geçici olarak kaldırdı.
3. Feature branch’in tabanını C3’ten C5’e taşıdı.
4. B1–B3’teki değişiklikleri C5’in üzerine yeni commit’ler olarak yeniden uyguladı: C6, C7, C8.


### Git Rebase Türleri 

1. İnteraktif Rebase (git rebase -i) 

- Bu, branch’inizdeki commit’leri düzenlemenize, squash yapmanıza, sıralamasını değiştirmenize veya silmenize olanak tanır. Commit history üzerinde tam kontrol sağlar; commit mesajlarını temizlemek veya birden fazla commit’i tek bir commit’te birleştirmek için faydalıdır.
- Commit’leri birleştirerek tek bir commit haline getirebilir.
- Git rebase, commit’leri daha mantıklı bir akışı yansıtacak şekilde yeniden sıralar.
- Commit mesajlarını, remote repository’ye göndermeden önce düzenlemek için kullanılabilir.  

2. İnteraktif Olmayan Rebase (Standart Rebase)  

- Bu, normal rebase komutudur (git rebase 'branch'). Commit’lerinizi hedef branch’in üzerine uygular, ancak manuel müdahaleye izin vermez. Bireysel commit’leri değiştirmek veya gözden geçirmek istemediğiniz basit rebase işlemleri için idealdir.
- Feature branch’inizi, main branch’teki en güncel değişikliklerle güncellemek için kullanılır.  

3. Otomatik Merge Rebase 

- Rebase yaparken, eğer rebase edilen commit’ler ile hedef branch arasında çatışma yoksa Git değişiklikleri otomatik olarak merge eder. Çatışmalar tespit edilirse, Git işlemi durdurur ve manuel çözüm gerektirir.
- Feature branch’leri sık sık rebase ederek main branch ile güncel kalmak için kullanılır.  

### Git Standard vs Git İnteraktif Rebase  

Git rebase iki modda çalışır: Standart ve İnteraktif. Mod, -i (interactive) bayrağının kullanılıp kullanılmadığına göre belirlenir. Hiçbir argüman verilmezse, Git rebase’i Standart modda çalıştırır. 

#### Standard Rebase 

Standart rebase, mevcut branch’teki tüm commit’leri hedef branch’in en son commit’ine manuel müdahale olmadan uygular. Aşağıdaki komut, standart bir rebase gerçekleştirir:  

``` bash
git rebase master branch_x
```    

Bu şuna eşdeğer:  

``` bash
git rebase master
```  
Burada, Git mevcut branch’inizdeki commit’leri otomatik olarak alır ve belirtilen branch’e (master) uygular.  

#### Git İnteraktif Rebase 

İnteraktif rebase, commit’leri yeni branch’e uygulamadan önce düzenlemenize, sıralamasını değiştirmenize, squash yapmanıza veya silmenize olanak tanır. Bu, branch’in commit history’si üzerinde tam kontrol sağlar.  

``` bash
git checkout branch_x
git rebase -i master
```   
Bu komut, taşınmak üzere olan tüm commit’leri listeler ve bunları düzenlemeniz veya yeniden sıralamanız için sizi yönlendirir. Proje history’sinin temiz ve düzenli kalmasına yardımcı olur.  

### Yaygın Git Rebase Komutları  

1. git rebase master: Mevcut branch’in değişikliklerini master branch’in üzerine uygular.
2. git rebase --continue: Çatışmalar çözüldükten sonra rebase işlemine devam eder.
3. git rebase --abort: Devam eden rebase’i iptal eder ve branch’i orijinal haline geri döndürür.
4. git rebase --skip: Çatışma durumunda bir commit’i atlar; ancak bu önerilmez çünkü kod tabanınıza zarar verebilir.
5. git rebase -i HEAD~3: Son üç commit üzerinde interaktif rebase başlatır; commit mesajlarını değiştirme gibi düzenlemelere olanak tanır.  

### Git Rebase’de Konfigrasyon Seçenekleri  

- --interactive (-i): Commit’leri düzenlemek için interaktif rebase’i etkinleştirir.
- --onto <newbase>: Rebase için yeni bir base commit belirtir.
- --no-verify: Rebase sırasında pre-commit hook’larını atlar.
- --auto-squash: fixup veya squash ile işaretlenmiş commit’leri otomatik olarak birleştirir.  

### Git Rebase Abort  

Bir rebase’i geri almak istiyorsanız git reset komutunu kullanın:  

``` bash
git reset --hard <branch-name>
```   
Bu, branch’inizi rebase işleminden önceki haline geri döndürür.  

### Kaybolan Değişiklikleri Kurtarma Adımları: Upstream Rebase Süreci  

Adım 1: Reflog'u kontrol edin  

Kaybolan commit’ler de dahil olmak üzere commit geçmişini görüntülemek için aşağıdaki komutu kullanın:

``` bash
git reflog
```  

Adım 2: Yeni Bir Branch Oluşturun  
``` bash
git branch <new-branch> <commit-id>
```  
Adım 3: Kaybolan Commit’leri Cherry-pick Yapın:   

Aşağıdaki komut, kaybolan commit’leri yeni branch’inize uygulamak için kullanılır:  
``` bash
git cherry pick <commit id> 
``` 

Adım 4: Conflict’leri Çözün  

``` bash
git add <file> 
```   

Adım 5: Yeni Branch’i Push Edin  

``` bash
git push -u origin <new-branch>
```   

### Git Pull Rebase

git pull --rebase komutu, remote repository’den güncellemeleri alır ve yerel commit’lerinizi bu değişikliklerin üzerine yeniden uygular; böylece lineer bir commit history oluşur.

Adımlar: 
- Fetch the remote repository:  
``` bash
git fetch <remote>
```  

- Yerel branch’i rebase edin: 

``` bash
git pull --rebase
``` 

### Git’te Upstream Branch Ayarlama  

Upstream branch, yerel branch’inizin takip ettiği remote branch’tir. Değişiklikleri senkronize etmek için bir referans görevi görür; böylece branch isimlerini tekrar tekrar belirtmeden fetch, pull ve push işlemlerini gerçekleştirebiliriz.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20251003170621589624/upstream.webp
width=400 height=200>  
</p> 

- Genellikle remote repo’daki bir branch’tir (örneğin origin/main).
- git push ve git pull işlemlerini basitleştirir.
- Her yerel branch, bir upstream branch’i takip eder.
- git push -u veya git branch -u ile ayarlanır.  

### Git Push Komutu ile Upstream Branch Ayarlama  

Git Push kullanarak Upstream Branch’i ayarlamak için önce ' ' adlı yeni bir branch oluşturmanız ve -b seçeneği ile o branch’e geçmeniz gerekir.  

``` bash
git checkout -b <branch name>
```  

Branch değiştirme işlemi sonrası onay aşağıda görünür: 

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220208105853/checkoutBranch.JPG
width=400 >  
</p>  

Mevcut branch’iniz (yani 'new_branch') için herhangi bir Upstream branch ayarlı değilse ve "git push" komutunu çalıştırmaya çalışırsanız, cmd’de aşağıdaki komutu çalıştırdıktan sonra:  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220208111011/NoUpstreamBranch.JPG
width=400 >  
</p>  

Şimdi, -u seçeneği ile Git push komutunu kullanarak upstream branch’i ayarlamanız gerekiyor. (branch name) kısmını kendi branch adınızla değiştirin.  

``` bash
git push -u origin <branch name>
```   

Alternatif olarak, Upstream branch’i ayarlamak için --set-upstream komutunu da kullanabilirsiniz.  

``` bash
git push --set-upstream origin <branch name>
```  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220208111959/SetUpstream.JPG
width=400>  
</p>  

### Git’te Upstream Branch’leri Değiştirme 

Şimdi, az önce ayarladığınızın yerine yeni bir upstream branch’i takip etmeniz gerekiyor. Bunu çalıştırarak yapabilirsiniz:  

``` bash
git branch -u <remote/branch name>
```  

Örnek Olarak: 

``` bash
git branch main -u <origin/new_branch>
git branch main -u <origin/main>
``` 

Terminal, onay mesajını aşağıdaki şekilde görüntüler: 

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220208114426/trackDiffBranch.JPG>  
</p>  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220208114544/trackDiffBranch.JPG>  
</p>  

### Hangi Branch’lerin Upstream Branch’leri Takip Ettiğini Kontrol Etme  

Şimdi, hangi Git branch’lerinin hangi upstream branch’leri takip ettiğini kontrol etmek için, -vv seçeneği ile git branch komutunu kullanarak tüm takip edilen branch’lerinizi listeleyebilirsiniz: 

``` bash
git branch -vv
```  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220208115207/trackingBranches.JPG
width=400>  
</p>  

Main branch’in [origin/main] adında bir tracking branch’i var.
Test branch’in [origin/test] adında bir tracking branch’i var.
New_branch branch’in [origin/new_branch] adında bir tracking branch’i var.   

### Git Squash  

Git squash, özellikle birçok küçük artımlı commit içeren feature branch’lerde, birden fazla commit’i alır ve bunları tek bir commit’te birleştirir. Bu, commit geçmişinin dağınık olmasını önler ve ekibe düzenli, takip etmesi kolay bir history sunar.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20251004165503909659/squashing_commit.webp
width=400>  
</p>  

### Git Squash-Merge Komut Satırı  

Bir feature branch’teki commit’leri tek bir commit’te birleştirip mevcut branch’inize merge etmek için şunu kullanabiliriz.  

``` bash
git merge --squash feature-branch
```  

Bu komut, feature dalındaki tüm commitleri tek bir commit hâline getirir ve mevcut dalınıza uygular. Squash merge yaptıktan sonra, repo geçmişi daha temiz ve düzenli hâle gelir.  

### Commitleri Nasıl Squash Ederiz 

1. İnteraktif Rebase Method   
Run:  

``` bash
git rebase -i HEAD~3
```   

- Bir etkileşimli editör açılır ve son 3 commit’i listeler.

- İlk commit ile birleştirmek istediğiniz commitlerde “pick” yerine “squash” yazın.

- Editörü kaydedip kapatın.

- Başka bir editör açılır ve burada birleşik commit mesajını yazabilirsiniz.

- Kaydedip çıkın, böylece rebase işlemi tamamlanmış olur.  

Bunun ardından, birden fazla commit’iniz tek bir commit hâline gelecektir.  

2. --squash Seçeneği ile Squash Yapmak 

Hedef branch’inizi oluşturun ve ona geçin:  

``` bash
git checkout main
```  

--squash seçeneği ile merge yapmak:  
``` bash
git merge --squash feature-branch
```  
- Herhangi bir merge çatışmasını manuel olarak çözün.
- Birleştirilmiş değişiklikleri bir mesaj ile commit edin:  

``` bash
git commit -m "Add group video calls and bug fixes"
```  

Değişiklikleri remote repository’ye push edin. 

### Git Squash vs Rebase  


### Git Squash ve Git Rebase Karşılaştırması

| Git Squash | Git Rebase |
| :--- | :--- |
| Birden fazla commit'i tek bir commit'te birleştirebilirsiniz. | Commit'leri farklı temel commit'lerin üzerine uygular. |
| `git squash` kullandıktan sonra commit geçmişiniz daha temiz ve düzenli olacaktır. | Önceki commit'leri kullanarak yeni bir dal (branch) oluşturabilirsiniz. |
| Yalnızca özel (private) branchlerde yapılmalıdır. | Rebase işlemi hem feature branch'inde hem de paylaşılan (shared) branch'inde yapılabilir. |
| Squishing kullanarak temiz ve mantıklı bir commit geçmişi sağlayabilirsiniz. | `rebase` komutunu kullanarak branch'inizi güncel tutabilirsiniz. |  

### Git - Fork 

Git’te fork, başka bir kullanıcının repository’sinin kişisel bir kopyası anlamına gelir. Bir repository’i fork ettiğinizde, kendi hesabınız veya organizasyonunuz içinde var olan bağımsız bir kopyasını oluşturursunuz. Bu kopya şunları içerir:  

- Tüm dosyalar

- Commit geçmişi

- Fork işlemi sırasında orijinal repository’de bulunan branch’ler  

### Neden Fork Kullanıyoruz ? 

Forking aşağıdaki durumlarda faydalıdır:

- Projeyi fork ettiğinizde, orijinal projeyi değiştirmeden kendi değişikliklerinizi test edebileceğiniz kendi proje kopyanıza sahip olursunuz.

- Bu, projenin maintainer’ının yaptığınız değişiklikleri daha iyi incelemesini sağlar ve bu kişi değişiklikleri kabul etme, reddetme veya öneride bulunma yetkisine sahiptir.

- Size ait olmayan bir Open-Source projeyi clone ettiğinizde, projeye doğrudan kod push etme hakkınız olmaz.  

#### Bir Repository’yi Fork Etmek için Adım Adım Rehber:  

Adım 1: Repository’ye gidin: 

- GitHub üzerinde fork etmek istediğimiz repository’yi açın.

- Repository sayfasının sağ üst köşesinde bir Fork butonu göreceğiz.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220323232607/Screenshot20220323232536.png
width=400>  
</p>  

Adım 2: Fork Butonuna Tıklayın: 

- GitHub hesabınızda repository’nin bir kopyasını oluşturmak için Fork butonuna tıklayın.

- python/cpython ifadesini görebiliriz. Bu, python’un maintainer olduğunu ve cpython’un projenin adı olduğunu gösterir.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220323233639/Screenshot20220323233633.png
width=400>  
</p>  

Adım 3: Fork'u Onaylayın: 

- Fork işleminden sonra, repository’yi kendi hesabımız altında göreceğiz.

- Repository adı, the-username/repository-name şeklinde görünecektir.

- Orijinal repository linki, fork edilen repository’nin altında hâlâ erişilebilir olacaktır.

- Sağ üst köşedeki Fork butonunu bulun  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220323233809/Screenshot20220323233759.png
width=400>  
</p>  

- Fork'a tıklayın. 

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220323233947/Screenshot20220323233914.png
width=400>  
</p>  

Adım 4: Değişiklik Yapın ve Bir Pull Request Oluşturun 

- Fork işleminden sonra, kendi repository’mizde değişiklikler yapabiliriz.

- Orijinal projeye katkıda bulunmak için bir Pull Request (PR) oluşturun.

- Maintainer’lar değişiklikleri inceleyip kabul edebilir veya reddedebilir.  

<p align="center">
<img src=https://media.geeksforgeeks.org/wp-content/uploads/20220323234103/Screenshot20220323234050.png
width=400>  
</p>   


### Git Fork vs Git Clone 

| Git Fork | Git Clone |
| :--- | :--- |
| Hesapta bir repository’nin bağımsız bir kopyasını oluşturur. | Mevcut bir remote repository’nin yerel bir kopyasını oluşturur. |
| Fork edilen repository bize aittir. | Clone edilen repository bize ait değildir. |
| Fork üzerinde yapılan değişiklikler orijinal repository’yi etkilemez. | Clone üzerinde yapılan değişiklikler, repository’ye push edilmedikçe sadece yerel olarak kalır. |
| Yerel geliştirme ve test için kullanılır. | Open-source katkıları ve bağımsız geliştirme için kullanılır. |  

### Fork’u Upstream Repository ile Senkronize Etmek için Git’i Yapılandırma 

Bir repository’yi fork ettikten sonra, onu orijinal proje ile güncel tutmak isteyebiliriz. Fork’u senkronize etmek için şu adımları izleyin: 

Adım 1: Fork'u clone'layın  

Fork ettiğimiz repository’yi, repository’yi saklamak istediğimiz dizine clone edin. Bunu yapmak için aşağıdaki komutu kullanın  
``` bash
git clone <forked-repository-URL>
```  

Adım 2: Upstream Repository’yi Ekleyin 

Upstream repository’yi, fork repository’ye bir remote olarak ekleyin. Bunu yapmak için aşağıdaki komutu kullanabiliriz.  

``` bash
cd <forkrepo>
git remote add upstream <original-repository-URL>
```  

Adım 3: Upstream Değişikliklerini Fetch Edin 

``` bash
git fetch upstream
```  
Adım 4: Upstream Değişikliklerini Branch’e Merge Edin  

Güncellemek istediğimiz branch’e geçmek için ve Upstream’den fetch edilen branch’leri merge etmek için aşağıdaki komutu kullan.  

``` bash
git checkout main
git merge upstream/main
```   

Adım 5: Değişiklikleri Fork Repository’ye Push Edin 

Aşağıdaki komut ile değişiklikleri fork repository’ye push edebiliriz. 

``` bash
git push origin main
```    

Artık fork edilen repository, orijinal repository ile sync hâline gelmiştir.

### Git config 

git config için en temel kullanım, komutu bir yapılandırma adı ile çağırmaktır; bu, o ad altında ayarlanmış değeri gösterir. Yapılandırma adları, hiyerarşilerine göre bir ‘section’ ve bir ‘key’den oluşan, nokta ile ayrılmış string’lerdir. Örneğin: user.email  

``` bash
git config user.email
```  

“Bu örnekte, email, user yapılandırma bloğunun bir alt özelliğidir. Bu komut, Git’in yerel olarak oluşturulan commit’lerle ilişkilendireceği, ayarlanmış e-posta adresini (varsa) döndürecektir.  

### git config seviyeleri ve dosyaları  

git config kullanımını daha detaylı tartışmadan önce, yapılandırma seviyelerini ele alalım. git config komutu, hangi yapılandırma seviyesi üzerinde işlem yapılacağını belirten argümanları kabul edebilir. Kullanılabilir yapılandırma seviyeleri şunlardır: 

- --local 

Varsayılan olarak, git config herhangi bir yapılandırma seçeneği verilmezse local seviyeye yazar. Local seviye yapılandırma, git config’in çalıştırıldığı repository bağlamına uygulanır. Local yapılandırma değerleri, repository’nin .git dizininde bulunan bir dosyada saklanır: .git/config  

- --global 

Global seviye yapılandırma kullanıcıya özeldir; yani bir işletim sistemi kullanıcısına uygulanır. Global yapılandırma değerleri, kullanıcının home dizininde bulunan bir dosyada saklanır: Unix sistemlerde ~/.gitconfig, Windows’ta C:\Users\<kullanıcı>\.gitconfig  

- --system 

ystem seviyesi yapılandırma, tüm makine genelinde uygulanır. Bu, işletim sistemindeki tüm kullanıcıları ve tüm repository’leri kapsar. System seviye yapılandırma dosyası, sistemin root yolu altında bir gitconfig dosyasında bulunur: Unix sistemlerde $(prefix)/etc/gitconfig. Windows’ta bu dosya, Windows XP’de C:\Documents and Settings\All Users\Application Data\Git\config, Windows Vista ve sonrasında ise C:\ProgramData\Git\config yolunda bulunur.

Böylece yapılandırma seviyelerinin öncelik sırası şu şekildedir: local, global, system. Bu, bir yapılandırma değeri ararken Git’in önce local seviyeden başlayıp system seviyesine kadar ilerleyeceği anlamına gelir.  

### Value Yazdırma 

``` bash
git config --global user.email "your_email@example.com"
``` 

Bu örnekte, user.email yapılandırma adına your_email@example.com değerini yazar. --global bayrağı kullanıldığı için bu değer, mevcut işletim sistemi kullanıcısı için ayarlanır.  

### git config editor - core.editor 

Birçok Git komutu, ek giriş almak için bir metin editörü başlatır. git config’in en yaygın kullanım senaryolarından biri, Git’in hangi editörü kullanacağını yapılandırmaktır. Aşağıda, popüler editörler ve karşılık gelen git config komutlarının bir tablosu verilmiştir: 

| Editor | config command |
| :--- | :--- |
| Atom | `git config --global core.editor "atom --wait"` |
| emacs | `git config --global core.editor "emacs"` |
| nano | `git config --global core.editor "nano -w"` |
| vim | `git config --global core.editor "vim"` |
| Sublime Text (Mac) | `git config --global core.editor "subl -n -w"` |
| Sublime Text (Win, 32-bit install) | `git config --global core.editor "'c:/program files (x86)/sublime text 3/sublimetext.exe' -w"` |
| Sublime Text (Win, 64-bit install) | `git config --global core.editor "'c:/program files/sublime text 3/sublimetext.exe' -w"` |
| Textmate | `git config --global core.editor "mate -w"` |  

### Merge araçları  

Bir merge conflict durumunda, Git bir ‘merge tool’ başlatır. Varsayılan olarak, Git yaygın Unix diff programının dahili bir uygulamasını kullanır. Dahili Git diff, minimal bir merge conflict görüntüleyicisidir. Bunun yerine kullanılabilecek birçok üçüncü taraf merge conflict çözüm aracı mevcuttur. 

``` bash
git config --global merge.tool kdiff3
```   

### Aliases 

İşletim sistemi komut satırından alias kavramına aşina olabilirsiniz; değilse, alias’lar, hangi komutun daha uzun veya birleştirilmiş komutlara dönüşeceğini tanımlayan özel kısa yollar olarak tanımlanabilir. Alias’lar, sık kullanılan komutları yazarken harcanan zaman ve enerji maliyetini azaltır. Git, kendi alias sistemini sunar. Git alias’larının yaygın bir kullanım senaryosu, commit komutunu kısaltmaktır. Git alias’ları, Git yapılandırma dosyalarında saklanır. Bu da demektir ki, alias’ları yapılandırmak için git config komutunu kullanabilirsiniz.  

``` bash
git config --global alias.ci commit
``` 

Bu örnek, git commit komutu için ci adında bir alias oluşturur. Daha sonra git commit yerine git ci komutunu çalıştırabilirsiniz. Alias’lar, güçlü kombinasyonlar oluşturmak için diğer alias’lara da referans verebilir.  

``` bash
git config --global alias.amend ci --amend
```   

Bu örnek, amend adında bir alias oluşturur ve ci alias’ını kullanarak --amend bayrağını kullanan yeni bir alias yaratır.  

### Formatlama ve Whitespace

Git, git diff kullanırken boşluk (whitespace) sorunlarını vurgulamak için yapılandırılabilecek birkaç ‘whitespace’ özelliğine sahiptir. Boşluk sorunları, color.diff.whitespace ile yapılandırılmış renk kullanılarak vurgulanacaktır.  

Aşağıdaki özellikler varsayılan olarak etkindir: 


- blank-at-eol: Satır sonlarında kalan gereksiz boşlukları vurgular

- space-before-tab: Bir satırı girintilerken tab karakterinden önce gelen boşluk karakterini vurgular

- blank-at-eof: Bir dosyanın sonunda eklenen boş satırları vurgular  

Aşağıdaki özellikler varsayılan olarak devre dışıdır: 

- indent-with-non-tab: Bir satırın tab yerine boşluklarla girintilenmesini vurgular

- tab-in-indent: Başlangıçtaki tab girintisini hata olarak vurgular

- trailing-space: Hem blank-at-eol hem de blank-at-eof için kısa bir gösterimdir

- cr-at-eol: Satır sonlarında carriage return karakterini vurgular

- tabwidth=: Bir tab karakterinin kaç karakter konumunu kapsadığını tanımlar. Varsayılan değer 8'miş. Geçerli değerler 1-63 arasındadır. 

### Git alias  

Doğrudan bir git alias komutu olmadığını belirtmek önemlidir. Alias’lar, git config komutu ve Git yapılandırma dosyaları kullanılarak oluşturulur. Diğer yapılandırma değerlerinde olduğu gibi, alias’lar local veya global kapsamda oluşturulabilir.

Git alias’larını daha iyi anlamak için bazı örnekler oluşturalım: 

``` bash
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```   
Önceki kod örneği, yaygın kullanılan git komutları için global olarak saklanan kısa yollar oluşturur. Alias’ları oluşturmak, orijinal komutları değiştirmez. Yani git checkout hâlâ kullanılabilir durumda olacak, hatta artık git co alias’ımız olsa bile. Bu alias’lar --global bayrağı ile oluşturulduğu için, Git’in global işletim sistemi seviyesindeki yapılandırma dosyasında saklanacaklar. Linux sistemlerde, global config dosyası kullanıcı home dizininde ~/.gitconfig yolunda bulunur. 


``` bash
    [alias]
        co = checkout
            br = branch
            ci = commit
            st = status
``` 

Bu, alias’ların artık orijinal komutlarla eşdeğer olduğunu gösterir. 

### Kullanımı 

Alias’lar iki temel yöntemle oluşturulabilir:

1. Git config dosyalarını doğrudan düzenlemek

Alias oluşturmak için global veya local config dosyaları manuel olarak düzenlenip kaydedilebilir. Global config dosyası $HOME/.gitconfig yolunda bulunur. Local config dosyası ise aktif bir git deposunun içinde /.git/config yolunda yer alır.

Config dosyaları, aşağıdaki gibi bir [alias] bölümüne uyacaktır:  

``` bash
[alias]
 co = checkout
``` 

2. Alias oluşturmak için git config kullanmak

Daha önce gösterildiği gibi, git config komutu alias’ları hızlıca oluşturmak için kullanışlı bir araçtır. Aslında git config komutu, global ve local Git config dosyalarına yazmak için bir yardımcı araçtır.


``` bash
git config --global alias.co checkout
``` 
Bu komutu çalıştırmak, önceki örneğimizde manuel olarak düzenlenen global config dosyasını güncelleyecektir.  

### Git diff 

### Reading Diff: çıktıların görüntülenmesi 

#### Ham (raw) çıktı formatı 

``` bash
$:> mkdir diff_test_repo
$:> cd diff_test_repo
$:> touch diff_test.txt
$:> echo "this is a git diff test example" > diff_test.txt
$:> git init .
Initialized empty Git repository in /Users/kev/code/test/.git/
$:> git add diff_test.txt
$:> git commit -am"add diff test file"
[main (root-commit) 6f77fc3] add diff test file
1 file changed, 1 insertion(+)
create mode 100644 diff_test.txt
```
Bu noktada git diff komutunu çalıştırırsak, herhangi bir çıktı olmayacaktır. Bu beklenen bir davranıştır çünkü repo’da diff yapılacak bir değişiklik yoktur. Repo oluşturulduktan ve diff_test.txt dosyası eklendikten sonra, diff çıktısı üzerinde denemeler yapmak için dosyanın içeriğini değiştirebiliriz.  

``` bash
$:> echo "this is a diff example" > diff_test.txt
```  

Bu komutu çalıştırmak, diff_test.txt dosyasının içeriğini değiştirecektir. Dosya değiştirildikten sonra, bir diff görüntüleyip çıktıyı analiz edebiliriz. Şimdi git diff komutunu çalıştırmak aşağıdaki çıktıyı üretecektir:  

``` bash
diff --git a/diff_test.txt b/diff_test.txt
index 6b0c6cf..b37e70a 100644
--- a/diff_test.txt
+++ b/diff_test.txt
@@ -1 +1 @@
-this is a git diff test example
+this is a diff example
```  
Şimdi diff çıktısının daha detaylı bir analizine bakalım. 

1. Karşılaştırma girdisi (comparison input) 

``` bash
diff --git a/diff_test.txt b/diff_test.txt
```  
Bu satır, diff’in giriş kaynaklarını gösterir. Diff’e a/diff_test.txt ve b/diff_test.txt dosyalarının verildiğini görebiliriz. 

2. Meta data 

``` bash
index 6b0c6cf..b37e70a 100644
```   
Bu satır bazı dahili Git meta verilerini gösterir. Muhtemelen bu bilgilere ihtiyaç duymayacaksınız. Çıktıdaki sayılar, Git nesne sürümü hash kimliklerine karşılık gelir. 

3. Değişiklikler için işaretleyiciler (markers for changes) 

``` bash
--- a/diff_test.txt
+++ b/diff_test.txt
``` 
Bu satırlar, her diff giriş kaynağına semboller atayan bir efsanedir (legend). Bu durumda, a/diff_test.txt dosyasındaki değişiklikler --- ile, b/diff_test.txt dosyasındaki değişiklikler ise +++ sembolü ile işaretlenir. 

4. Diff parçaları 

Kalan diff çıktısı, diff ‘parçaları’nın (chunks) bir listesidir. Diff yalnızca değişiklik olan dosya bölümlerini gösterir. Mevcut örneğimizde, basit bir senaryo üzerinde çalıştığımız için yalnızca bir chunk vardır. Chunk’ların kendi detaylı çıktı anlamları (granular output semantics) vardır. 


``` bash
@@ -1 +1 @@
-this is a git diff test example
+this is a diff example
```  
İlk satır chunk başlığıdır. Her chunk, @@ sembolleri ile çevrili bir başlık ile başlar. Başlığın içeriği, dosyada yapılan değişikliklerin özetini gösterir. Basitleştirilmiş örneğimizde -1 +1 ifadesi, birinci satırda değişiklik yapıldığını gösterir. Daha gerçekçi bir diff’te, şöyle bir başlık görebiliriz: 

``` bash
@@ -34,6 +34,8 @@
```  

Bu başlık örneğinde, 34. satırdan başlayarak 6 satır çıkarılmıştır. Ayrıca, 34. satırdan başlayarak 8 satır eklenmiştir.

Diff chunk’ın kalan içeriği, yapılan son değişiklikleri gösterir. Her değiştirilen satırın başında, değişikliğin hangi diff girişinden geldiğini belirten + veya - sembolü bulunur. Daha önce tartıştığımız gibi, - sembolü a/diff_test.txt dosyasındaki değişiklikleri, + sembolü ise b/diff_test.txt dosyasındaki değişiklikleri gösterir. 

### Binary dosyalarını diff’leme

git diff binary dosyalar üzerinde de çalıştırılabilir fakat varsayılan çıktı pek faydalı değil. 

``` bash
$:> git diff
Binary files a/script.pdf and b/script.pdf differ
``` 

Git, binary dosyalarınızın içeriğini diff işleminden önce metne dönüştürmek için bir shell komutu belirtmenize olanak tanıyan bir özelliğe sahiptir. Ancak, bunun için biraz kurulum gereklidir. Öncelikle, belirli bir binary türünü metne nasıl dönüştüreceğinizi tanımlayan bir textconv filtresi belirtmeniz gerekir. Biz PDF’lerimi insan tarafından okunabilir HTML’e dönüştürmek için Homebrew üzerinden kullanılabilen basit bir araç olan pdftohtml’i kullanıyoruz. Bunu tek bir repository için .git/config dosyasını düzenleyerek veya global olarak ~/.gitconfig dosyasını düzenleyerek ayarlayabiliriz. 


``` bash
[diff "pdfconv"]
textconv=pdftohtml -stdout
```  

Daha sonra yapmanız gereken tek şey, bir veya daha fazla dosya desenini pdfconv filtresi ile ilişkilendirmektir. Bunu, repository’nizin kök dizininde bir .gitattributes dosyası oluşturarak yapabiliriz.  

``` bash
*.pdf diff=pdfconv
```  

Bir kez yapılandırıldıktan sonra, git diff önce binary dosyayı yapılandırılmış dönüştürücü script üzerinden geçirir ve dönüştürücü çıktısı üzerinde diff işlemi yapar. Aynı teknik, her türlü binary dosyadan faydalı diff almak için uygulanabilir, örneğin:

- Arşivler (zips, jars vb.): unzip -l (veya benzeri) kullanarak pdf2html yerine, commit’ler arasında eklenen veya kaldırılan yolları görebilirsiniz.

- Resimler: exiv2 kullanılarak, örneğin resim boyutları gibi metadata değişiklikleri gösterilebilir.

- Dokümanlar: .odf, .doc ve diğer doküman formatlarını düz metne dönüştüren araçlar mevcuttur.

- Acil durumlar: Resmî bir dönüştürücü yoksa, binary dosyalar için strings sıklıkla işe yarar. 

### Dosyaları karşılaştırma: git diff (file) 

git diff komutuna belirli bir dosya yolu parametresi verilebilir. Bir dosya yolu verildiğinde, diff işlemi sadece belirtilen dosya ile sınırlı olur. Aşağıdaki örnekler bu kullanım şeklini göstermektedir. 

``` bash
git diff HEAD ./path/to/file
```  

Bu örnek, ./path/to/file dosyası ile sınırlıdır; çalıştırıldığında, çalışma dizinindeki belirli değişiklikleri index ile karşılaştırır ve henüz stage edilmemiş değişiklikleri gösterir. Varsayılan olarak git diff, karşılaştırmayı HEAD ile yapar. Yukarıdaki örnekte HEAD’i atlamak (git diff ./path/to/file) aynı sonucu verir. 

``` bash
git diff --cached ./path/to/file
``` 

git diff komutu --cached seçeneği ile çalıştırıldığında, diff stage edilmiş değişiklikleri yerel repository ile karşılaştırır. --cached seçeneği, --staged ile eşanlamlıdır. 

### Tüm değişiklikleri karşılaştırma 

git diff komutu dosya yolu belirtilmeden çalıştırıldığında, değişiklikler tüm repository üzerinde karşılaştırılır. Yukarıdaki dosya özelindeki örnekler, ./path/to/file argümanı olmadan çalıştırıldığında, yerel repository’deki tüm dosyalar için aynı çıktı sonucunu verir. 

### Son commit’ten beri yapılan değişiklikler

Varsayılan olarak git diff, son commit’ten bu yana yapılan henüz commit edilmemiş değişiklikleri gösterir.

``` bash
git diff
``` 
### İki farklı commit arasındaki dosyaları karşılaştırma

git diff komutuna diff yapmak için Git referansları (refs) verilebilir. Örnek referanslar: HEAD, tag’ler ve branch isimleridir. Git’te her commit’in bir commit ID’si vardır; bunu git log çalıştırdığınızda görebilirsiniz. Bu commit ID’sini git diff komutuna da verebiliriz. 

``` bash
git log --pretty=oneline
957fbc92b123030c389bf8b4b874522bdf2db72c add feature
ce489262a1ee34340440e55a0b99ea6918e19e7a rename some classes
6b539f280d8b0ec4874671bae9c6bed80b788006 refactor some code for feature
646e7863348a427e1ed9163a9a96fa759112f102 add some copy to body

$:> git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a
```

### Branch’leri karşılaştırma 

#### İki branch’i karşılaştırma 

``` bash
git diff branch1..other-feature-branch
``` 

This example introduces the dot operator. The two dots in this example indicate the diff input is the tips of both branches. The same effect happens if the dots are omitted and a space is used between the branches. Additionally, there is a three dot operator: 

``` bash
git diff branch1...other-feature-branch
``` 

Üç nokta (...) operatörü, diff işlemini başlatırken ilk girdi parametresi branch1 üzerinde değişiklik yapar. branch1, iki diff girdisinin paylaşılan ortak atası (common ancestor) commit’inin referansı haline getirilir; yani branch1 ve other-feature-branch’in ortak atası. Son parametre olan other-feature-branch ise değişmeden, branch’in ucu (tip) olarak kalır.  

Belirli bir dosyayı branch’ler arasında karşılaştırmak için, dosya yolunu git diff komutuna üçüncü argüman olarak verin. 

``` bash
git diff main new_branch ./diff_test.txt
```  

### Git stash 

git stash komutu, commit edilmemiş değişikliklerinizi (hem staged hem unstaged olanları) alır, daha sonra kullanmak üzere saklar ve ardından çalışma kopyanızdan geri alır. Örneğin: 

``` bash
$ git status
On branch main
Changes to be committed:

    new file:   style.css

Changes not staged for commit:

    modified:   index.html

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
nothing to commit, working tree clean
```  

Bu noktada değişiklik yapabilir, yeni commit’ler oluşturabilir, branch değiştirebilir ve diğer Git işlemlerini gerçekleştirebilirsiniz; hazır olduğunuzda stash’inizi tekrar uygulayabilirsiniz.

Stash Git deposuna özeldir; push yaptığınızda stash’ler sunucuya aktarılmaz.

### Stash’lediğiniz değişiklikleri tekrar uygulama

Daha önce stash’lenmiş değişiklikleri git stash pop ile tekrar uygulayabilirsin 
``` bash
$ git status
On branch main
nothing to commit, working tree clean
$ git stash pop
On branch main
Changes to be committed:

    new file:   style.css

Changes not staged for commit:

    modified:   index.html

Dropped refs/stash@{0} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)
``` 

Stash’ini popladığında, değişiklikler stash’inden çıkarılır ve çalışma kopyana tekrar uygulanır. 

Alternatif olarak, değişiklikleri çalışma kopyana tekrar uygulayabilir ve stash’inde tutmaya devam edebilirsin git stash apply ile: 

``` bash
$ git stash apply
On branch main
Changes to be committed:

    new file:   style.css

Changes not staged for commit:

    modified:   index.html
```   

Bu, aynı stash’lenmiş değişiklikleri birden fazla branch’e uygulamak istediğinde kullanışlıdır.

Artık stash’in temellerini bildiğine göre, git stash ile ilgili bilmen gereken bir uyarı var: varsayılan olarak Git, takip edilmeyen (untracked) veya ignore edilen dosyalardaki değişiklikleri stash’lemez. 

### Untracked veya ignore edilen dosyaları stash’lemek 

Varsayılan olarak git stash, şu değişiklikleri stash’ler:

- Index’e eklenmiş (staged) değişiklikler

- Git’in takip ettiği dosyalardaki (unstaged) değişiklikler 

Ama şunları stash’lemez: 

- alışma kopyanda, henüz stage edilmemiş yeni dosyalar

- Ignore edilmiş dosyalar 

Yani, yukarıdaki örneğimize üçüncü bir dosya eklersek ama bunu stage etmezsek (yani git add çalıştırmazsak), git stash bu dosyayı stash’lemez.

``` bash
$ script.js

$ git status
On branch main
Changes to be committed:

    new file:   style.css

Changes not staged for commit:

    modified:   index.html

Untracked files:

    script.js

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
Untracked files:

    script.js
```   

-u (veya --include-untracked) seçeneğini eklediğinde, git stash untracked dosyalarını da stash’ler: 


``` bash
$ git status
On branch main
Changes to be committed:

    new file:   style.css

Changes not staged for commit:

    modified:   index.html

Untracked files:

    script.js

$ git stash -u
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
nothing to commit, working tree clean
```   

git stash komutunu -a (veya --all) seçeneğiyle çalıştırarak, ignore edilmiş dosyalardaki değişiklikleri de stash’leyebiliriz. 

### Birden fazla stash’i yönetme 

Sadece tek bir stash ile sınırlı değilsin. git stash’i birkaç kez çalıştırarak birden fazla stash oluşturabilir ve ardından git stash list ile bunları görüntüleyebilirsin. Varsayılan olarak, stash’ler sadece oluşturulduğu branch ve commit’in üstünde bir “WIP” – work in progress (devam eden çalışma) – olarak tanımlanır. Bir süre sonra, her stash’in ne içerdiğini hatırlamak zorlaşabilir. 


``` bash
$ git stash list
stash@{0}: WIP on main: 5002d47 our new homepage
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage
``` 

Daha iyi bir bağlam sağlamak için, stash’lerine açıklama eklemek iyi bir uygulamadır. Bunu git stash save "mesaj" komutuyla yapılabilinir.

``` bash
$ git stash save "add style to our site"
Saved working directory and index state On main: add style to our site
HEAD is now at 5002d47 our new homepage

$ git stash list
stash@{0}: On main: add style to our site
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage
``` 

“Git stash pop, varsayılan olarak en son oluşturulan stash’i (stash@{0}) tekrar uygular.

Belirli bir stash’i tekrar uygulamak istersen, son argüman olarak onun kimliğini verebilirsin, örneğin: 

``` bash
$ git stash pop stash@{2}
```  
### Stash farklarını görüntüleme 

Bir stash’in özetini git stash show ile görüntüleyebilirsin: 

``` bash
$ git stash show
 index.html | 1 +
 style.css | 3 +++
 2 files changed, 4 insertions(+)
``` 

-p seçeneğini (veya --patch) ekleyerek bir stash’in tam diff’ini görüntüleyebilirsin: 

``` bash
$ git stash show -p
diff --git a/style.css b/style.css
new file mode 100644
index 0000000..d92368b
--- /dev/null
+++ b/style.css
@@ -0,0 +1,3 @@
+* {
+  text-decoration: blink;
+}
diff --git a/index.html b/index.html
index 9daeafb..ebdcbd2 100644
--- a/index.html
+++ b/index.html
@@ -1 +1,2 @@
+<link rel="stylesheet" href="style.css"/>
``` 

### Bölümlü (partial) stash’ler

Ayrıca sadece tek bir dosyayı, bir dosya koleksiyonunu veya dosya içindeki bireysel değişiklikleri stash’lemeyi de seçebilirsin. git stash’e -p seçeneğini (veya --patch) verirsen, çalışma kopyandaki her değişiklik “hunk”u üzerinden geçer ve bunu stash’lemek isteyip istemediğini sorar: 

``` bash
$ git stash -p
diff --git a/style.css b/style.css
new file mode 100644
index 0000000..d92368b
--- /dev/null
+++ b/style.css
@@ -0,0 +1,3 @@
+* {
+  text-decoration: blink;
+}
Stash this hunk [y,n,q,a,d,/,e,?]? y
diff --git a/index.html b/index.html
index 9daeafb..ebdcbd2 100644
--- a/index.html
+++ b/index.html
@@ -1 +1,2 @@
+<link rel="stylesheet" href="style.css"/>
Stash this hunk [y,n,q,a,d,/,e,?]? n
``` 
Hunk komutlarının tüm listesini görmek için ? tuşuna basmak lazım. En çok kullanılanlar şunlar:

| Komut | Açıklama |
| :---: | :--- |
| / | Hunk’ları regex kullanarak arama |
| ? | yardım |
| n | Bu hunk’u stash’leme |
| q | quit |
| s | Bu hunk’u daha küçük hunk’lara böl |
| y | bu hunk'u stash'le | 

Stash işlemini iptal etmek için doğrudan bir ‘abort’ komutu yoktur, fakat CTRL-C (SIGINT) ile işlemi durdurabilinir. 

### Stash’ten yeni bir branch oluşturma 

Branch’ndeki değişiklikler stash’indeki değişikliklerden ayrılmışsa, stash’i poplamak veya apply etmek çatışmalara yol açabilir. Bunun yerine, git stash branch komutuyla stash’lediğin değişiklikleri uygulayacağın yeni bir branch oluşturabiliriz.

``` bash
$ git stash branch add-stylesheet stash@{1}
Switched to a new branch 'add-stylesheet'
On branch add-stylesheet
Changes to be committed:

    new file:   style.css

Changes not staged for commit:

    modified:   index.html

Dropped refs/stash@{1} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)
``` 

Bu, stash’i oluşturduğun commit’i temel alarak yeni bir branch oluşturur ve ardından stash’lenmiş değişikliklerini bu branch’e pop’lar 

### Stash’i temizleme 

Belirli bir stash’i artık kullanmayacaksan, git stash drop komutuyla silebilirsin: 

``` bash
$ git stash drop stash@{1}
Dropped stash@{1} (17e2697fd8251df6163117cb3d58c1f62a5e7cdb)
``` 
ya da hepsini bu komutla silebilirsin: 

``` bash
$ git stash clear
```  
### Git Stash Nasıl Çalışır ? 

Stash’ler aslında repository’inde commit objeleri olarak kodlanır. .git/refs/stash içindeki özel ref, en son oluşturduğun stash’e işaret eder ve daha önce oluşturulmuş stash’ler stash ref’in reflog’u aracılığıyla referanslanır. Bu yüzden stash’leri stash@{n} ile gösterirsin: aslında stash ref’in n’inci reflog girdisine işaret ediyorsun. Bir stash sadece bir commit olduğundan, git log ile inceleyebilirsin.

Stash’lediğin şeye bağlı olarak, tek bir git stash işlemi iki veya üç yeni commit oluşturur. Yukarıdaki diyagramdaki commit’ler şunlardır:

- stash@{0}, git stash’i çalıştırdığında çalışma kopyandaki takip edilen (tracked) dosyaları saklamak için oluşturulan yeni commit

- stash@{0}’ın birinci parent’ı, git stash’i çalıştırdığında HEAD’de bulunan mevcut commit

- stash@{0}’ın ikinci parent’ı, git stash’i çalıştırdığında index’i temsil eden yeni commit

- stash@{0}’ın üçüncü parent’ı, git stash’i çalıştırdığında çalışma kopyandaki untracked dosyaları temsil eden yeni commit. Bu üçüncü parent yalnızca oluşturulur eğer:

- çalışma kopyanda gerçekten untracked dosyalar varsa; ve

- git stash’i çalıştırırken --include-untracked veya --all seçeneğini belirttiysen. 

Git stash, çalışma ağacını ve index’i commit’ler olarak nasıl saklar:

- Stash yapmadan önce, çalışma kopyanda takip edilen dosyalarda, untracked dosyalarda ve ignore edilmiş dosyalarda değişiklikler bulunabilir. Bu değişikliklerin bazıları index’e (stage edilmiş) eklenmiş olabilir.


<p align="center">
<div style="background-color: #e6ffe6; padding: 20px; border-radius: 5px;">
  <img src="https://wac-cdn.atlassian.com/dam/jcr:35edaf68-e8b1-484e-b5f0-292c532f048a/04.svg?cdnVersion=3036" style="display: block; margin: 0 auto;"
  height=300>
</div>
</p> 

--all seçeneğini kullanmak, takip edilmeyen (untracked) dosyalardaki değişikliklerin yanında ignore edilmiş dosyalardaki değişiklikleri de aynı commit’e dahil eder.

<p align="center">
<div style="background-color: #e6ffe6; padding: 20px; border-radius: 5px;">
  <img src="https://wac-cdn.atlassian.com/dam/jcr:446fad60-0ff5-4383-8177-a5fc2813364d/06.svg?cdnVersion=3036" style="display: block; margin: 0 auto;"
  height=300>
</div>
</p> 

git stash pop komutunu çalıştırdığında, ilgili commit’lerdeki değişiklikler çalışma kopyanı ve index’i günceller ve stash reflog, pop edilen commit’i kaldıracak şekilde güncellenir. Pop edilen commit’ler hemen silinmez, fakat ileride garbage collection sırasında temizlenebilirler. 

### Git ignore 

Git, çalışma kopyandaki her dosyayı üç kategoriden biri olarak görür:

1. tracked (takip edilen) – daha önce stage edilmiş veya commit edilmiş dosya;

2. untracked (takip edilmeyen) – henüz stage edilmemiş veya commit edilmemiş dosya;

3. ignored (yoksayılan) – Git’e açıkça yoksayması söylenen dosya.

Ignore edilen dosyalar genellikle build artifaktları veya makine tarafından üretilen ve repository kaynağından türetilebilecek ya da commit edilmemesi gereken dosyalardır. Bazı yaygın örnekler şunlardır:

- Bağımlılık önbellekleri, örneğin /node_modules veya /packages içeriği

- Derlenmiş kod dosyaları, örneğin .o, .pyc, .class dosyaları

- Build çıktı dizinleri, örneğin /bin, /out, /target

- Çalışma zamanı üretilen dosyalar, örneğin .log, .lock, .tmp

- Gizli sistem dosyaları, örneğin .DS_Store, Thumbs.db

- Kişisel IDE yapılandırma dosyaları, örneğin .idea/workspace.xml

Ignore edilen dosyalar, repository’nin kök dizininde yer alan ve versiyon kontrolüne alınmış özel bir .gitignore dosyasında takip edilir. Git’te doğrudan bir git ignore komutu yoktur; yeni ignore edilmesi gereken dosyalar için .gitignore dosyası elle düzenlenip commit edilmelidir. .gitignore dosyaları, repository’deki dosya isimleriyle eşleşen desenler (pattern) içerir ve dosyaların ignore edilip edilmeyeceğini belirler. 

### Git için ignore kuralları 
.gitignore dosyaları, dosya isimlerini eşleştirmek için globbing desenleri kullanır. Bu desenleri farklı sembollerle oluşturulabilinir: 

## .gitignore Kalıpları ve Kuralları

| Kalıp / Kural | Açıklama | Eşleşen Örnekler | Eşleşmeyen Örnekler |
| :--- | :--- | :--- | :--- |
| **`/logs`** | Eğik çizgi (slash) olmadan kullanıldığında, hem **o isimdeki dosyaları hem de dizinleri ve içeriklerini** eşleştirir. | `logs`, `logs/debug.log`, `logs/monday/foo.bar`, `build/logs`, `build/logs/debug.log` | - |
| **`logs/`** | Eğik çizgi (slash) **eklendiğinde**, kalıbın bir **dizin** olduğunu belirtir. Bu isimle eşleşen tüm dizinlerin tüm içeriği yoksayılır. | `logs/debug.log`, `logs/latest/foo.bar`, `build/logs/foo.bar`, `build/logs/latest/debug.log` | - |
| **`**/logs/debug.log`** | Çift yıldız (**`**`) bir kalıbın başına eklendiğinde, **depodaki herhangi bir dizinde** eşleşme sağlar. | `logs/debug.log`, `build/logs/debug.log` | `logs/build/debug.log` |
| **`logs/**/debug.log`** | Çift yıldız (**`**`) iki eğik çizgi arasında kullanıldığında, **sıfır veya daha fazla dizini** eşleştirir. | `logs/debug.log`, `logs/monday/debug.log`, `logs/monday/pm/debug.log` | - |
| **`logs/debug.log`** | Belirli bir dizindeki dosyayı belirtir. Kalıplar depo köküne göre **görecelidir**. | `logs/debug.log` | `debug.log`, `build/logs/debug.log` |
| **`*.log`** | Yıldız işareti (**`*`**), **sıfır veya daha fazla karakteri** eşleştiren bir genel karakterdir (wildcard). | `debug.log`, `foo.log`, `.log`, `logs/debug.log` | - |
| **`!important.log`** | Ünlem işareti (**`!`**), kalıbı **tersine çevirir** (negates). Daha önce eşleşen (yoksayılan) bir dosyayı tekrar izlemeye dahil eder. | `!important.log` dosyası izlenir. | `*.log` tarafından yoksayılanlar hariç. |
| **`/debug.log`** | Başa eklenen eğik çizgi (**`/`**) yalnızca **depo kökündeki** dosyaları eşleştirir. | `debug.log` | `logs/debug.log` |
| **`debug?.log`** | Soru işareti (**`?`**), **tam olarak bir karakteri** eşleştirir. | `debug0.log`, `debugg.log` | `debug10.log` |
| **`debug[0-9].log`** | Köşeli parantezler (**`[]`**) **belirtilen aralıktan** tek bir karakteri eşleştirmek için kullanılır. Aralıklar sayısal veya alfabetik olabilir. | `debug0.log`, `debug1.log` | `debug10.log` |
| **`debug[01].log`** | Köşeli parantezler (**`[]`**) **belirtilen kümeden** tek bir karakteri eşleştirir. | `debug0.log`, `debug1.log` | `debug2.log`, `debug01.log` |
| **`debug[!01].log`** | Ünlem işareti (**`!`**) **belirtilen küme dışındaki** herhangi bir karakteri eşleştirmek için kullanılır. | `debug2.log` | `debug0.log`, `debug1.log`, `debug01.log` |
| **`logs/*day/debug.log`** | Genel karakterler (**`*`**) **dizin adlarında** da kullanılabilir. | `logs/monday/debug.log`, `logs/tuesday/debug.log` | `logs/latest/debug.log` |
| **`logs/` ve `!logs/important.log`** | **Önemli Kural:** Bir dizin (`logs/`) yoksayılıyorsa, **içindeki bir dosya** (`!logs/important.log`) **tersine çevrilemez** (negate edilemez). Bu, Git'in performansla ilgili bir özelliğidir. | `logs/debug.log` | `logs/important.log` **(Yoksayılmaya Devam Eder)** |


.gitignore dosyanda yorum eklemek için # karakterini kullanabilirsin: 

``` bash
# ignore all logs
*.log
``` 

Eğer dosya veya klasör isimlerinde .gitignore desenlerinde özel anlam taşıyan karakterler varsa (*, ?, [ ], vs.), bu karakterlerin önüne \ koyarak git’in onları düz karakter olarak görmesini sağlayabilirsin. 

``` bash
# ignore the file literally named foo[01].txt
foo\[01\].txt
``` 
### Repository’ndeki paylaşılan .gitignore dosyaları 


1. .gitignore dosyasının yeri

- Git ignore kuralları genellikle repository’nin root dizininde bir .gitignore dosyasında tanımlanır.

- Bu dosya, git’in hangi dosya ve klasörleri track etmeyeceğini belirtir.

2. Birden fazla .gitignore dosyası kullanmak

- İstersen repository içindeki farklı dizinlerde de .gitignore dosyaları oluşturabilirsin.

- Her .gitignore dosyasındaki pattern (desen), o dosyanın bulunduğu dizine göre test edilir.
Örnek: src/.gitignore içindeki *.tmp deseni yalnızca src/ dizinindeki .tmp dosyalarını ignore eder.

3. Konvansiyon ve en basit yaklaşım

- En yaygın ve basit yöntem, tek bir .gitignore dosyası kullanmak ve onu root dizine koymaktır.

4. .gitignore dosyası versioned bir dosyadır

- .gitignore repository’ye eklendiğinde, tıpkı diğer dosyalar gibi version kontrolüne girer.

- Push yaptığında takım arkadaşlarınla paylaşılır.

5. Kime fayda sağladığına dikkat et

- .gitignore dosyasına eklenen pattern’ler, repository’yi kullanan diğer kişiler için de faydalı olmalıdır.

- Örneğin, senin kişisel deneme dosyalarını ignore etmek için eklediğin pattern, başkası için gereksiz olabilir. 

### Daha önce commit edilmiş bir dosyayı ignore etme

Daha önce commit ettiğiniz bir dosyayı ignore etmek istiyorsanız, önce dosyayı repository’den silmeniz ve ardından .gitignore kuralı eklemeniz gerekir. git rm komutunu --cached seçeneği ile kullanmak, dosyanın repository’den silinmesini sağlar, ancak çalışma dizininizde ignore edilmiş bir dosya olarak kalır. 

``` bash
$ echo debug.log >> .gitignore
  
$ git rm --cached debug.log
rm 'debug.log'
  
$ git commit -m "Start ignoring debug.log"
``` 

Eğer dosyayı hem repository’den hem de yerel dosya sisteminizden silmek istiyorsanız, --cached seçeneğini kullanmayabilirsiniz. 

### Ignore edilmiş bir dosyayı commit etme 

Ignore edilmiş bir dosyayı repository’ye commit etmeyi zorlamak mümkündür; bunu git add komutunu -f (veya --force) seçeneği ile kullanarak yapabilirsiniz. 

``` bash
$ cat .gitignore
*.log
  
$ git add -f debug.log
  
$ git commit -m "Force adding debug.log"
``` 

Bunu, eğer genel bir pattern (örneğin *.log) tanımladıysanız ama belirli bir dosyayı commit etmek istiyorsanız düşünebilirsiniz. Ancak daha iyi bir çözüm, genel kurala bir istisna tanımlamaktır. 

``` bash
$ echo !debug.log >> .gitignore
  
$ cat .gitignore
*.log
!debug.log
  
$ git add debug.log
  
$ git commit -m "Adding debug.log"
```  
### Debugging .gitignore Dosyaları 

Eğer karmaşık .gitignore pattern’leriniz varsa veya pattern’ler birden fazla .gitignore dosyasına dağılmışsa, belirli bir dosyanın neden ignore edildiğini bulmak zor olabilir. git check-ignore komutunu -v (veya --verbose) seçeneği ile kullanarak, hangi pattern’in o dosyanın ignore edilmesine neden olduğunu öğrenebilirsiniz. 

``` bash
$ git check-ignore -v debug.log
.gitignore:3:*.log  debug.log
```  

Çıktı şunu gösterir: 

``` bash
<file containing the pattern> : <line number of the pattern> : <pattern>    <file name>
``` 
İstersen git check-ignore komutuna birden fazla dosya adı verebilirsin ve dosya adlarının repository’de gerçekten var olan dosyalar olması da gerekmez.

## Bir repository’yi inceleme 

**git status:** 

git status komutu, çalışma dizininin ve staging alanının durumunu gösterir. Hangi değişikliklerin stage edildiğini, hangilerinin edilmediğini ve hangi dosyaların Git tarafından takip edilmediğini görmenizi sağlar. git status çıktısı, commit edilmiş proje geçmişi hakkında herhangi bir bilgi vermez. Bunun için git log komutunu kullanmanız gerekir. 

**Bağlantılı git komutları:**
- git tag  

Tag’ler, Git geçmişindeki belirli noktalara işaret eden ref’lerdir. git tag genellikle, belirli bir sürüm yayınını işaretlemek için kullanılır (örneğin: v1.0.1).

- git blame 

git blame komutunun temel işlevi, bir dosyadaki belirli satırlara eklenmiş commit yazar bilgilerini (author metadata) görüntülemektir. Bu komut, belirli bir kodun geçmişini incelemek ve kodun repository’ye ne, nasıl ve neden eklendiğini anlamak için kullanılır. 

- git log 

git log komutu, commit edilmiş snapshot’ları gösterir. Bu komut, proje geçmişini listelemenizi, filtrelemenizi ve belirli değişiklikleri aramanızı sağlar. 

### Discussion 

git status komutu nispeten basit bir komuttur. Sadece git add ve git commit ile neler olduğunu gösterir. Status mesajları ayrıca dosyaları stage etme veya stage’den çıkarma ile ilgili ilgili talimatları da içerir. Aşağıda, git status komutunun üç ana kategoriyi gösteren örnek bir çıktısı verilmiştir: 

``` bash
# On branch main
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
#
#modified: hello.py
#
# Changes not staged for commit:
# (use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working directory)
#
#modified: main.py
#
# Untracked files:
# (use "git add <file>..." to include in what will be committed)
#
#hello.pyc
```  

### Dosyları ignore'lama 

Git tarafından takip edilmeyen (untracked) dosyalar genellikle iki kategoriye ayrılır. Bunlar ya projeye yeni eklenmiş ve henüz commit edilmemiş dosyalardır, ya da .pyc, .obj, .exe gibi derlenmiş ikili dosyalardır. Öncekileri git status çıktısında görmek kesinlikle faydalıdır, ancak ikincileri görmek, repository’de neler olup bittiğini anlamayı zorlaştırabilir.

Bu nedenle, Git, .gitignore adında özel bir dosya kullanarak dosyaları tamamen ignore etmenizi sağlar. Ignore etmek istediğiniz her dosya ayrı bir satıra eklenmelidir ve * sembolü joker karakter (wildcard) olarak kullanılabilir. Örneğin, proje kök dizininde .gitignore dosyasına aşağıdakileri eklemek, derlenmiş Python modüllerinin git status çıktısında görünmesini engeller: 

``` bash
*.pyc
```  
### git log 

git log komutu, commit edilmiş snapshot’ları gösterir. Proje geçmişini listelemenizi, filtrelemenizi ve belirli değişiklikleri aramanızı sağlar. git status komutu çalışma dizinini ve staging alanını incelemenize izin verirken, git log yalnızca commit edilmiş geçmiş üzerinde çalışır. 

<p align="center">
<div style="background-color: #e6ffe6; padding: 20px; border-radius: 5px;">
  <img src="https://wac-cdn.atlassian.com/dam/jcr:52d530ce-7f51-48e3-920b-a18f776048d3/01.svg?cdnVersion=3036" style="display: block; margin: 0 auto;"
  height=200>
</div>
</p> 

git log çıktısı, commit’leri filtrelemekten tamamen kullanıcı tanımlı bir formatta görüntülemeye kadar çeşitli şekillerde özelleştirilebilir. git log komutunun en yaygın yapılandırmalarından bazıları aşağıda verilmiştir.  

### Kullanımı 

``` bash
git log
``` 
Tüm commit geçmişini varsayılan formatla görüntüler. Eğer çıktı bir ekranı aşarsa, kaydırmak için Space tuşunu, çıkmak için q tuşu. 

``` bash
git log -n <limit>
``` 
Commit sayısını sınırlama. Örneğin, git log -n 3 komutu yalnızca 3 commit gösterecektir. 

Her commit’i tek bir satırda özetleme. Bu, proje geçmişinin genel bir görünümünü elde etmek için kullanılır. 

``` bash
git log --oneline
``` 

``` bash
git log --stat
``` 

Normal git log bilgisine ek olarak, hangi dosyaların değiştirildiğini ve her bir dosyadan kaç satırın eklendiğini veya silindiğini gösterme. 

``` bash
git log -p
``` 

Her commit’i temsil eden patch’i (farkları) görüntüleme. Bu, her commit’in tam diff’ini gösterir ve proje geçmişinizin alabileceği en detaylı görünümüdür. 

``` bash
git log --author="<pattern>"
``` 

Belirli bir yazar tarafından yapılmış commit’leri arama. (pattern) argümanı düz bir metin veya düzenli ifade (regular expression) olabilir.

``` bash
git log --grep="<pattern>"
```  
Commit mesajı (pattern) ile eşleşen commit’leri arama. (pattern) düz bir metin veya düzenli ifade (regular expression) olabilir. 

``` bash
git log <since>..<until>
``` 
Yalnızca (since) ve (until) arasında gerçekleşen commit’leri gösterme. Her iki argüman da commit ID, bir branch adı, HEAD veya başka bir tür revizyon referansı olabilir. 

``` bash
git log <file>
```  

Sadece belirtilen dosyayı içeren commit’leri gösterin. Bu, belirli bir dosyanın geçmişini görmek için kolay bir yoldur. 

``` bash
git log --graph --decorate --oneline
``` 

Birkaç yararlı seçenek:

- --graph → Commit mesajlarının sol tarafında metin tabanlı bir grafik çizer.

- --decorate → Gösterilen commit’lerin branch veya tag isimlerini ekler.

- --oneline → Commit bilgilerini tek satırda gösterir, böylece commit’ler hızlıca gözden geçirilebilir.

### Git clean 

Git clean bir ölçüde bir “geri alma” komutu olarak düşünülebilir. Git clean, git reset ve git checkout gibi diğer komutları tamamlayıcı olarak değerlendirilebilir. Diğer komutlar daha önce Git takip indeksine eklenmiş dosyalar üzerinde çalışırken, git clean komutu takip edilmeyen (untracked) dosyalar üzerinde çalışır. Takip edilmeyen dosyalar, depo çalışma dizininizde oluşturulmuş ancak henüz git add komutu ile Git takip indeksine eklenmemiş dosyalardır. 

Takip edilen (tracked) ve takip edilmeyen (untracked) dosyalar arasındaki farkı daha iyi göstermek için aşağıdaki komut satırı örneğini inceleyin.

``` bash
$ mkdir git_clean_test
$ cd git_clean_test/
$ git init .
Initialized empty Git repository in /Users/kev/code/git_clean_test/.git/
$ echo "tracked" > ./tracked_file
$ git add ./tracked_file
$ echo "untracked" > ./untracked_file
$ mkdir ./untracked_dir && touch ./untracked_dir/file
$ git status
On branch master

Initial commit

Changes to be committed: (use "git rm --cached <file>..." to unstage)

new file: tracked_file

Untracked files: (use "git add <file>..." to include in what will be committed) untracked_dir/ untracked_file
``` 

Örnek, git_clean_test dizininde yeni bir Git deposu oluşturur. Daha sonra Git indeksine eklenen bir tracked_file oluşturulur; ayrıca bir untracked_file ve bir untracked_dir oluşturulur. Örnek, ardından git status komutunu çalıştırır; bu komut, Git’in takip edilen ve edilmeyen değişikliklerle ilgili iç durumunu gösterir. Depo bu durumda iken, git clean komutu çalıştırılarak amacının nasıl işlediği gösterilebilir. 

``` bash
$ git clean fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean
```  

Bu noktada, varsayılan git clean komutunu çalıştırmak ölümcül bir hata (fatal error) üretebilir. Yukarıdaki örnek bunun nasıl görünebileceğini göstermektedir. Varsayılan olarak, Git global olarak git clean komutunun çalışması için “force” (zorla) seçeneğinin verilmesini gerektirir. Bu, önemli bir güvenlik mekanizmasıdır. git clean sonunda çalıştırıldığında geri alınamaz. Tam olarak yürütüldüğünde, git clean tıpkı komut satırındaki rm komutunu çalıştırmak gibi, dosya sisteminde kalıcı silme işlemi gerçekleştirir. Komutu çalıştırmadan önce gerçekten takip edilmeyen dosyaları silmek istediğinizden emin olun. 

### Yaygın seçenekler ve kullanım

Varsayılan git clean davranışları ve uyarılarıyla ilgili önceki açıklamalardan yola çıkarak, aşağıdaki içerik çeşitli git clean kullanım örneklerini ve bu işlemlerin gerçekleştirilmesi için gereken komut satırı seçeneklerini göstermektedir. 

``` bash
-n
```  

-n seçeneği, git clean komutunu bir “dry run” (deneme çalıştırması) olarak gerçekleştirir. Bu, hangi dosyaların silineceğini göstermenize olanak sağlar, ancak dosyalar gerçekten silinmez. git clean komutunu çalıştırmadan önce her zaman bir dry run yapmak en iyi uygulamadır. Bu seçeneği, daha önce oluşturduğumuz demo repoda gösterebiliriz. 

``` bash
$ git clean -n
Would remove untracked_file
```  

Çıktı bize, git clean komutu çalıştırıldığında untracked_file dosyasının silineceğini gösterir. Burada untracked_dir dizininin çıktıda rapor edilmediğine dikkat edin. Varsayılan olarak, git clean dizinler üzerinde özyinelemeli (recursive) olarak çalışmaz. Bu, kazara kalıcı silme işlemlerini önlemek için bir başka güvenlik mekanizmasıdır. 

``` bash
-f or --force
```  
force seçeneği, mevcut dizindeki takip edilmeyen dosyaların gerçekten silinmesini başlatır. clean.requireForce yapılandırma seçeneği false olarak ayarlanmadıkça, force kullanımı gereklidir. Bu seçenek, .gitignore ile belirtilen takip edilmeyen dosya veya dizinleri silmez. Şimdi, örnek repomuzda canlı bir git clean işlemi gerçekleştirelim

``` bash
$ git clean -f 
Removing untracked_file
```  
Komut, silinen dosyaları çıktı olarak gösterecektir. Burada untracked_file dosyasının silindiğini görebilirsiniz. Bu noktada git status komutunu çalıştırmak veya ls yapmak, untracked_file dosyasının silindiğini ve artık bulunmadığını gösterecektir. Varsayılan olarak, git clean -f mevcut dizindeki tüm takip edilmeyen dosyalar üzerinde çalışır. Ayrıca, -f seçeneği ile bir (path) değeri verilerek belirli bir dosya da silinebilir.  

``` bash
git clean -f <path>
-d include directorie
```  

-d seçeneği, git clean komutuna takip edilmeyen dizinleri de silmek istediğinizi söyler; varsayılan olarak dizinler göz ardı edilir. Önceki örneklerimize -d seçeneğini ekleyebiliriz: 

``` bash
$ git clean -dn
Would remove untracked_dir/
$ git clean -df
Removing untracked_dir/
``` 

Burada, -dn kombinasyonunu kullanarak bir dry run (deneme çalıştırması) gerçekleştirdik; çıktı olarak untracked_dir dizininin silinmeye hazır olduğunu gösterdi. Ardından, zorla temizlik (forced clean) komutunu çalıştırdık ve çıktı olarak untracked_dir dizininin silindiğini gördük. 

``` bash
-x force removal of ignored files
```  

Yaygın bir yazılım sürümleme pratiği, build veya distribution gibi dizinleri depodaki takip edilen dosya indeksine dahil etmemektir. Bu build dizini, commit edilmiş kaynak koddan üretilen geçici (ephemeral) build çıktıları içerir. Bu build dizini genellikle depodaki .gitignore dosyasına eklenir. Diğer takip edilmeyen dosyalarla birlikte bu dizini temizlemek de pratik olabilir. -x seçeneği, git clean komutuna göz ardı edilen (ignored) dosyaları da dahil etmesini söyler. Önceki git clean çağrılarında olduğu gibi, önce bir dry run yapmak en iyi uygulamadır. -x seçeneği, yalnızca proje build dizini ile sınırlı kalmaz, tüm ignored dosyalar üzerinde çalışır; örneğin .idea gibi IDE konfigürasyon dosyalarını da silebilir. 

``` bash
git clean -xf
``` 

-d seçeneğinde olduğu gibi, -x seçeneği de diğer seçeneklerle birlikte birleştirilebilir. Bu örnek, -f ile kombinasyonunu gösterir; bu sayede mevcut dizindeki takip edilmeyen dosyaları ve Git’in genellikle göz ardı ettiği dosyaları siler. 

### Etkileşimli mod veya git clean etkileşimli (interactive) 

Şimdiye kadar gösterdiğimiz geçici (ad-hoc) komut satırı çalıştırmalarına ek olarak, git clean komutunun “etkileşimli” modu vardır ve bu mod -i seçeneği ile başlatılabilir. Bu belgeye giriş bölümünde oluşturduğumuz örnek depoya geri dönelim. O ilk durumda, bir etkileşimli temizleme (interactive clean) oturumu başlatacağız. 

``` bash
$ git clean -di
Would remove the following items:
  untracked_dir/  untracked_file
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: help
What now>
```   
Etkileşimli oturumu -d seçeneği ile başlattık, böylece takip edilmeyen dizinimiz (untracked_dir) de işlemin kapsamına alınacak. Etkileşimli mod, What now> istemini gösterir ve takip edilmeyen dosyalara uygulanacak bir komut girmenizi ister. Komutlar oldukça açıklayıcıdır. Rastgele bir sırayla, 6. komut: help ile başlayarak kısa bir göz atalım. 6. komutu seçmek, diğer komutları daha ayrıntılı açıklar. 

``` bash
What now> 6
clean               - start cleaning
filter by pattern   - exclude items from deletion
select by numbers   - select items to be deleted by numbers
ask each            - confirm each deletion (like "rm -i")
quit                - stop cleaning
help                - this screen
?                   - help for prompt selection
```  

``` bash
5: quit
```   

Basit ve anlaşılırdır, ayrıca etkileşimli oturumdan çıkış yapar. 

``` bash
1: clean
```   

Belirtilen öğeleri silecektir. Bu noktada 1: clean komutunu çalıştırırsak, untracked_dir/ ve untracked_file silinecektir. 

``` bash
4: ask each
```  
Her takip edilmeyen dosya üzerinde tek tek işlem yapacak ve silme için Y/N istemi gösterecektir. Şöyle görünür: 

``` bash
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: help
What now> 4
Remove untracked_dir/ [y/N]? N
Remove untracked_file [y/N]? N
``` 

``` bash
2: filter by pattern 
```   

Takip edilmeyen dosya listesini filtrelemek için kullanılan bir girdi alanı ile ek bir istem görüntüler. 

``` bash
Would remove the following items:
  untracked_dir/  untracked_file
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: help
What now> 2
  untracked_dir/  untracked_file
Input ignore patterns>> *_file
  untracked_dir/
``` 
Burada *_file joker (wildcard) desenini girdik, bu da takip edilmeyen dosya listesini yalnızca untracked_file ile sınırlar. 

``` bash
3: select by numbers
```  
Komut 2’ye benzer şekilde, komut 3 de takip edilmeyen dosya adları listesini daraltmak için çalışır. Etkileşimli oturum, takip edilmeyen dosya adlarına karşılık gelen numaraları girmenizi ister. 

``` bash
Would remove the following items:
  untracked_dir/  untracked_file
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: help
What now> 3
    1: untracked_dir/    2: untracked_file
Select items to delete>> 2
    1: untracked_dir/  * 2: untracked_file
Select items to delete>>
Would remove the following item:
  untracked_file
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: help
```  

### Git Revert 

git revert komutu bir tür “geri alma” (undo) komutu olarak düşünülebilir, ancak klasik bir geri alma işlemi değildir. Bu komut, projeden bir commit’i kaldırmak yerine, commit tarafından yapılan değişiklikleri tersine çevirmenin yolunu bulur ve ortaya çıkan ters içerik ile yeni bir commit oluşturur. Bu, Git’in geçmişi kaybetmesini önler ve revizyon geçmişinin bütünlüğü ile güvenilir işbirliği açısından önemlidir.

Geri alma işlemi, proje geçmişinizdeki bir commit’in tersini uygulamak istediğinizde kullanılmalıdır. Örneğin, bir hatayı takip ederken bunun tek bir commit ile ortaya çıktığını bulursanız faydalı olabilir. Elle gidip hatayı düzeltmek ve yeni bir snapshot commit etmek yerine, git revert komutunu kullanarak bunu otomatik olarak yapabiliriz.  

### Nasıl Çalışıyor 

git revert komutu, bir repository’deki commit geçmişindeki değişiklikleri geri almak için kullanılır. git checkout ve git reset gibi diğer “geri alma” komutları, HEAD ve branch referans işaretçilerini belirtilen commit’e taşır. git revert de belirli bir commit alır, ancak referans işaretçilerini bu commit’e taşımaz. Bir revert işlemi, belirtilen commit’i alır, bu commit’in değişikliklerini tersine çevirir ve yeni bir “revert commit” oluşturur. Referans işaretçileri daha sonra yeni revert commit’i gösterecek şekilde güncellenir ve bu commit branch’in sonu (tipi) olur.

Örnek göstermek için, aşağıdaki komut satırı örneklerini kullanarak bir repository oluşturalım: 

``` bash
$ mkdir git_revert_test
$ cd git_revert_test/
$ git init .
Initialized empty Git repository in /git_revert_test/.git/
$ touch demo_file
$ git add demo_file
$ git commit -am"initial commit"
[main (root-commit) 299b15f] initial commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 demo_file
$ echo "initial content" >> demo_file
$ git commit -am"add new content to demo file"
[main 3602d88] add new content to demo file
n 1 file changed, 1 insertion(+)
$ echo "prepended line content" >> demo_file
$ git commit -am"prepend content to demo file"
[main 86bb32e] prepend content to demo file
 1 file changed, 1 insertion(+)
$ git log --oneline
86bb32e prepend content to demo file
3602d88 add new content to demo file
299b15f initial commit
```   

Burada, git_revert_test adında yeni oluşturulmuş bir dizinde bir repository başlattık. Repository’ye 3 commit yaptık; bu commitlerde demo_file adlı bir dosya ekledik ve içeriğini iki kez değiştirdik. Repository kurulum işleminin sonunda, commit geçmişini göstermek için git log komutunu çalıştırdık ve toplam 3 commit görüntülendi. Repository bu durumda iken, bir git revert işlemine başlamak için hazırız. 

``` bash
$ git revert HEAD
[main b9cd081] Revert "prepend content to demo file" 1 file changed, 1 deletion(-)
```  

git revert komutu, bir commit referansı bekler ve bu referans verilmeden çalışmaz. Burada HEAD referansını verdik; bu, en son commit’i geri alacaktır. Bu, tıpkı 3602d8815dbfa78cd37cd4d189552764b5e96c58 commit’ine geri dönmüş gibi bir davranıştır. Merge işlemine benzer şekilde, revert de yeni bir commit oluşturur ve yapılandırılmış sistem editörünü açarak yeni bir commit mesajı girilmesini ister. Commit mesajı girilip kaydedildikten sonra Git işlemi devam eder. Şimdi git log ile repository’nin durumunu inceleyebilir ve önceki log’a yeni bir commit’in eklendiğini görebiliriz. 

``` bash
$ git log --oneline 1061e79 Revert "prepend content to demo file" 86bb32e prepend content to demo file 3602d88 add new content to demo file 299b15f initial commit
```  

Dikkat edilmesi gereken nokta, 3. commit’in revert işleminden sonra da proje geçmişinde hâlâ bulunmasıdır. Git revert, bu commit’i silmek yerine, değişikliklerini geri almak için yeni bir commit ekledi. Sonuç olarak, 2. ve 4. commit’ler tam olarak aynı kod tabanını temsil eder ve 3. commit geçmişimizde hâlâ durur; ileride tekrar ona dönmek istersek kullanabiliriz. 

### Sık Kullanılanlar 

``` bash
-e
--edit
``` 

Bu, varsayılan bir seçenektir ve belirtilmesine gerek yoktur. Bu seçenek, yapılandırılmış sistem editörünü açar ve revert commit’ini yapmadan önce commit mesajını düzenlemenizi ister. 

``` bash
--no-edit
```

Bu, -e seçeneğinin tersidir. Revert işlemi editörü açmaz.

``` bash
-n
--no-commit
```  

Bu seçeneğin verilmesi, git revert komutunun hedef commit’in değişikliklerini tersine çeviren yeni bir commit oluşturmasını engeller. Bunun yerine, tersine çevrilmiş değişiklikler Staging Index (Hazırlık Alanı) ve Working Directory’ye (Çalışma Dizini) eklenir. Bu, Git’in repository’nin durumunu yönetmek için kullandığı diğer “ağaçlardır”. Daha fazla bilgi için git reset sayfasına bakabilirsiniz. 

### Resetting vs. reverting 

Git revert’in yalnızca tek bir commit’i geri aldığını anlamak önemlidir—projenin önceki durumuna dönmek için tüm sonraki commit’leri silmez. Git’te bunu yapmak aslında “revert” değil, “reset” olarak adlandırılır 

<p align="center">
<div style="background-color: #e6ffe6; padding: 20px; border-radius: 5px;">
  <img src="https://wac-cdn.atlassian.com/dam/jcr:a6a50d78-48e3-4765-8492-9e48dec8fd2f/04%20(2).svg?cdnVersion=3036" style="display: block; margin: 0 auto;"
  height=200>
</div>
</p>  

Revert işleminin reset’e göre iki önemli avantajı vardır. Birincisi, proje geçmişini değiştirmez; bu nedenle, paylaşılmış bir repository’de zaten yayınlanmış commit’ler için “güvenli” bir işlemdir.

İkincisi, git revert geçmişteki herhangi bir commit’i hedef alabilirken, git reset yalnızca mevcut commit’ten geriye doğru çalışabilir. Örneğin, eski bir commit’i git reset ile geri almak isteseydiniz, hedef commit’ten sonra gelen tüm commit’leri kaldırmanız, hedef commit’i silmeniz ve ardından sonraki commit’leri yeniden commit etmeniz gerekirdi. Söylemeye gerek yok, bu şık bir geri alma çözümü değildir. 

### Git reset 

Git reset komutu, değişiklikleri geri almak için kullanılan karmaşık ve çok yönlü bir araçtır. Üç ana kullanım biçimi vardır: **--soft**, **--mixed** ve **--hard**. Bu üç seçenek, Git’in üç dahili durum yönetim mekanizmasına karşılık gelir: Commit Ağacı (HEAD), Staging Index ve Çalışma Dizini (Working Directory). 

Git’in Üç Ağacı (Three Trees)

Git, bir proje deposundaki dosya durumunu üç farklı "ağaç" üzerinden yönetir:

1. Commit Tree (HEAD)

- Son commit’i gösterir, yani proje geçmişi.

- Her commit, dosyaların o anki anlık görüntüsünü saklar.

2. Staging Index (Stage / Index / Cache)

- git add ile eklenen dosyalar burada tutulur.

- Bir sonraki commit’in neyi içereceğini belirler.

3. Working Directory (Çalışma Dizini)

Bilgisayarınızdaki gerçek dosyalar.

Değişiklik yaptığınız dosyalar burada görünür ama henüz commit edilmemiş olabilir. 

Yeni bir Git deposu oluşturmak için aşağıdaki adımları kullanabiliriz.

``` bash
$ mkdir git_reset_test
$ cd git_reset_test/
$ git init .
Initialized empty Git repository in /git_reset_test/.git/
$ touch reset_lifecycle_file
$ git add reset_lifecycle_file
$ git commit -m"initial commit"
[main (root-commit) d386d86] initial commit
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100644 reset_lifecycle_file
```  

Yukarıdaki örnek kod, içinde tek bir boş dosya (reset_lifecycle_file) bulunan yeni bir Git deposu oluşturur. Bu noktada örnek depoda, reset_lifecycle_file dosyasının eklenmesinden oluşan tek bir commit (d386d86) vardır. 

### The working directory 

İnceleyeceğimiz ilk ağaç "Çalışma Dizini" (Working Directory).
Bu ağaç, yerel dosya sistemi ile senkronizedir ve dosya ve dizinlerde yapılan anlık değişiklikleri temsil eder. 

``` bash
$ echo 'hello git reset' > reset_lifecycle_file
 $ git status 
 On branch main
 Changes not staged for commit: 
 (use "git add ..." to update what will be committed) 
 (use "git checkout -- ..." to discard changes in working directory) 
 modified: reset_lifecycle_file
```  

Demo deposunda, reset_lifecycle_file dosyasına bazı içerikler ekleyip değişiklik yaptık. git status komutunu çalıştırdığımızda, Git’in dosyadaki değişikliklerin farkında olduğunu görebiliriz. Bu değişiklikler şu anda ilk ağaç olan "Çalışma Dizini" (Working Directory)’nin bir parçasıdır.

git status komutu, Çalışma Dizini’ndeki değişiklikleri göstermek için kullanılabilir. Bu değişiklikler kırmızı renkte ve modified (değiştirildi) etiketi ile görüntülenir. 

### Staging index 

Sırada "Staging Index" (Hazırlama Alanı) ağacı var.
Bu ağaç, git add ile bir sonraki commit’e dahil edilmek üzere Çalışma Dizini’ndeki değişiklikleri takip eder. Bu ağaç, karmaşık bir dahili önbellekleme mekanizmasıdır. Git genellikle Staging Index’in uygulama detaylarını kullanıcıdan gizlemeye çalışır.

Staging Index’in durumunu doğru bir şekilde görmek için daha az bilinen bir Git komutu olan git ls-files kullanılmalıdır. git ls-files komutu, temelde Staging Index ağacının durumunu incelemek için bir debug (hata ayıklama) aracıdır. 

``` bash
git ls-files -s
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0   reset_lifecycle_file
``` 

Burada git ls-files komutunu -s veya --stage seçeneği ile çalıştırdık.
-s seçeneği olmadan git ls-files çıktısı, indeksin şu anda içindeki dosya isimleri ve yollarının basit bir listesidir.

-s seçeneği, Staging Index’teki dosyalar için ek meta verileri gösterir. Bu meta veriler; staged (hazırlanan) içeriğin mode bitleri, object name ve stage numarasıdır.

Burada ilgilendiğimiz değer object name, yani ikinci değer (d7d77c1b04b5edd5acfc85de0b592449e5303770). Bu, standart bir Git obje SHA-1 hash’idir. Dosya içeriğinin bir hash’i olarak çalışır.

Commit geçmişi kendi obje SHA’larını, commit ve ref pointerlarını tanımlamak için saklar. Staging Index ise indeks içindeki dosyaların sürümlerini takip etmek için kendi obje SHA’larını kullanır. 

Sıradaki adımda, değiştirilmiş reset_lifecycle_file dosyasını Staging Index’e (Hazırlama Alanı’na) ekleyeceğiz. 

``` bash
$ git add reset_lifecycle_file 

 
$ git status 

 
On branch main Changes to be committed: 

 
(use "git reset HEAD ..." to unstage) 

 
modified: reset_lifecycle_file
``` 

Burada git add reset_lifecycle_file komutunu çalıştırdık ve bu komut dosyayı Staging Index’e ekledi.
Şimdi git status komutunu çalıştırdığımızda, reset_lifecycle_file dosyasını “Changes to be committed” (Commit edilecek değişiklikler) başlığı altında yeşil renkte görebiliriz.

Burada dikkat edilmesi gereken önemli bir nokta, git status çıktısının Staging Index’in gerçek halini tam olarak yansıtmadığıdır.
git status komutu, Commit Geçmişi (Commit History) ile Staging Index arasındaki farkları gösterir.

Şimdi bu noktada Staging Index’in içeriğini inceleyelim.  

``` bash
$ git ls-files -s 100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
``` 

Görüyoruz ki reset_lifecycle_file dosyasının object SHA değeri
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 değerinden
d7d77c1b04b5edd5acfc85de0b592449e5303770 değerine güncellenmiş. 

### Commit history 

Son ağaç Commit History (Commit Geçmişi)’dir.
git commit komutu, yapılan değişiklikleri Commit History içinde kalıcı olarak saklanan bir anlık görüntü (snapshot) olarak ekler.
Bu anlık görüntü, commit anındaki Staging Index’in durumunu da içerir. 


``` bash
$ git commit -am"update content of reset_lifecycle_file"
[main dc67808] update content of reset_lifecycle_file
1 file changed, 1 insertion(+)
$ git status
On branch main
nothing to commit, working tree clean
```  

Burada "update content of resetlifecyclefile" mesajı ile yeni bir commit oluşturduk.
Bu değişiklik seti artık Commit History (Commit Geçmişi)’ne eklendi.

Bu noktada git status komutunu çalıştırdığımızda, hiçbir ağaçta bekleyen değişiklik olmadığını görebiliriz.
git log komutunu çalıştırmak ise Commit History’yi görüntüler.

Artık bu değişiklik setinin üç ağacın (Working Directory, Staging Index, Commit History) her birinden nasıl geçtiğini gördüğümüze göre, git reset komutunu kullanmaya başlayabiliriz. 

### Nasıl Çalışır 

Yüzeysel olarak bakıldığında, git reset komutu davranış açısından git checkout komutuna benzer.
Ancak aralarında önemli bir fark vardır:
git checkout yalnızca HEAD referans işaretçisi (ref pointer) üzerinde çalışırken,
git reset hem HEAD referans işaretçisini hem de mevcut branch’in referans işaretçisini hareket ettirir.

Bu davranışı daha iyi gösterebilmek için aşağıdaki örneği ele alalım: 

<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion3036>
</p> 

Bu örnek, main branch’i üzerindeki bir commit dizisini göstermektedir.
Şu anda HEAD referansı ve main branch referansı, d commit’ini işaret etmektedir.

Şimdi, hem git checkout b hem de git reset b komutlarını çalıştırıp karşılaştıralım. 

### git checkout b 

<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:f45c4a34-8968-4c81-83cf-d55ebf01a447/02%20git-checkout-transparent%20kopiera.png?cdnVersion3036>
</p>  

git checkout komutu çalıştırıldığında, main referansı hâlâ d commit’ini işaret etmeye devam eder.
Ancak HEAD referansı taşınmış ve artık b commit’ini işaret etmektedir.
Bu durumda repo, "detached HEAD" (bağımsız HEAD) durumundadır. 

### git reset b 

<p align="center"> 
<img src=<p align="center"> 
<img src=https://wac-cdn.atlassian.com/dam/jcr:bdf5fda3-4aac-4170-ba35-58f7a66ea3c4/03%20git-reset-transparent%20kopiera.png?cdnVersion3036>
</p>  

Karşılaştıracak olursak, git reset komutu hem HEAD hem de branch referanslarını belirtilen commit’e taşır.

Commit referans işaretçilerini güncellemenin yanı sıra, git reset üç ağacın (three trees) durumunu da değiştirir.
Referans işaretçisinin (ref pointer) güncellenmesi her zaman gerçekleşir ve bu işlem üçüncü ağaç olan Commit Tree (Commit Ağacı) üzerinde bir güncellemedir.

Komut satırı argümanları olan --soft, --mixed ve --hard,
Staging Index ve Working Directory ağaçlarının nasıl değiştirileceğini belirler. 

### Ana Seçenekler 

git reset komutunun varsayılan kullanımı, örtük olarak --mixed ve HEAD argümanlarını içerir.
Bu, git reset komutunu çalıştırmanın, git reset --mixed HEAD komutunu çalıştırmakla aynı anlama geldiği anlamına gelir.

Bu biçimde, HEAD belirtilen commit’tir.
Ancak HEAD yerine herhangi bir Git SHA-1 commit hash değeri de kullanılabilir. 

<p align="center">
<div style="background-color: #e6ffe6; padding: 20px; border-radius: 5px;">
  <img src="https://wac-cdn.atlassian.com/dam/jcr:7fb4b5f7-a2cd-4cb7-9a32-456202499922/03%20(8).svg?cdnVersion=3036" style="display: block; margin: 0 auto;"
  height=200>
</div>
</p> 

### --hard 

Bu, en doğrudan, TEHLİKELİ ve sık kullanılan seçenektir. --hard argümanı verildiğinde:

1. Commit History referans göstergeleri belirtilen commit’e güncellenir.

2. Ardından, Staging Index ve Working Directory, belirtilen commit ile eşleşecek şekilde sıfırlanır.

Bu, Staging Index ve Working Directory’de bekleyen herhangi bir değişikliğin Commit Tree’nin durumu ile eşleşecek şekilde kaybolacağı anlamına gelir. Yani, üzerinde çalışmakta olduğunuz herhangi bir değişiklik silinir.

Bunu göstermek için, daha önce oluşturduğumuz üç ağaç örnek deposu üzerinde devam edelim.
Öncelikle repoda bazı değişiklikler yapalım. Örnek depo içinde aşağıdaki komutları çalıştırın:

``` bash
$ echo 'new file content' > new_file
$ git add new_file
$ echo 'changed content' >> reset_lifecycle_file
```  

Bu komutlar, new_file adında yeni bir dosya oluşturmuş ve depoya eklemiş oldu. Ayrıca, reset_lifecycle_file dosyasının içeriği de değiştirilmiş durumda.

Bu değişiklikler yapıldıktan sonra, repodaki durumu incelemek için git status komutunu çalıştıralım. 

``` bash
$ git status
On branch main
Changes to be committed:
   (use "git reset HEAD ..." to unstage)

new file: new_file

Changes not staged for commit:
   (use "git add ..." to update what will be committed)
   (use "git checkout -- ..." to discard changes in working directory)

modified: reset_lifecycle_file
```  

Burada git add reset_lifecycle_file komutunu çalıştırdık ve bu dosya Staging Index’e eklendi.

git status komutunu çalıştırdığımızda, reset_lifecycle_file dosyasının “Changes to be committed” başlığı altında yeşil renkte göründüğünü fark ederiz.

Önemli bir nokta: git status, Staging Index’in gerçek içeriğini tam olarak göstermez. Bunun yerine, Commit History ile Staging Index arasındaki farkları gösterir.

Şimdi bu noktada Staging Index içeriğini inceleyelim. 

``` bash
$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
```  

Burada görebiliyoruz ki new_file Staging Index’e eklenmiş durumda. reset_lifecycle_file üzerinde bazı değişiklikler yaptık, ancak Staging Index içindeki SHA (d7d77c1b04b5edd5acfc85de0b592449e5303770) hâlâ aynı.

Bu beklenen bir davranıştır çünkü bu değişiklikleri Staging Index’e taşımak için git add kullanmadık. Bu değişiklikler hâlen Working Directory’de bulunuyor.

Şimdi git reset --hard komutunu çalıştıralım ve repository’nin yeni durumunu inceleyelim. 

``` bash
$ git reset --hard
HEAD is now at dc67808 update content of reset_lifecycle_file
$ git status
On branch main
nothing to commit, working tree clean
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
``` 

Burada --hard seçeneğiyle bir "hard reset" gerçekleştirdik. Git, HEAD’in en son commit olan dc67808’i işaret ettiğini belirten bir çıktı gösteriyor.

Ardından git status ile repository’nin durumunu kontrol ettik. Git, bekleyen değişiklik olmadığını belirtiyor. Staging Index’i incelediğimizde, new_file eklenmeden önceki duruma geri döndüğünü görüyoruz.

Yani reset_lifecycle_file üzerindeki değişikliklerimiz ve new_file eklememiz kaybolmuş durumda. Bu veri kaybı geri alınamaz, bu nedenle dikkatli olmak kritik öneme sahip. 

### --mixed 

Varsayılan işletim modu budur.

- Ref pointer’ları güncellenir.

- Staging Index, belirtilen commit’in durumuna sıfırlanır.

- Staging Index’ten geri alınan değişiklikler Working Directory’ye taşınır.

Yani, değişiklikler commit edilmemişse kaybolmaz; sadece indeksten çıkarılır ve çalışma dizinine geri gelir. Devam edelim. 

``` bash
$ echo 'new file content' > new_file
$ git add new_file
$ echo 'append content' >> reset_lifecycle_file
$ git add reset_lifecycle_file
$ git status
On branch main
Changes to be committed:
    (use "git reset HEAD ..." to unstage)

new file: new_file
modified: reset_lifecycle_file


$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 7ab362db063f9e9426901092c00a3394b4bec53d 0 reset_lifecycle_file
``` 

Yukarıdaki örnekte, depoda bazı değişiklikler yaptık.

- Yeni bir new_file ekledik ve reset_lifecycle_file dosyasının içeriğini değiştirdik.

- Bu değişiklikleri Staging Index’e almak için git add kullandık.

Depo bu durumda iken şimdi git reset komutunu çalıştıracağız. 

``` bash
$ git reset --mixed
$ git status
On branch main
Changes not staged for commit:
    (use "git add ..." to update what will be committed)
    (use "git checkout -- ..." to discard changes in working directory)

modified: reset_lifecycle_file

Untracked files:
    (use "git add ..." to include in what will be committed)

new_file


no changes added to commit (use "git add" and/or "git commit -a")
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
``` 

Burada bir “mixed reset” gerçekleştirdik. Tekrar etmek gerekirse, --mixed varsayılan modu temsil eder ve git reset komutuyla aynı etkiye sahiptir.

- git status ve git ls-files çıktısına baktığımızda, Staging Index’in yalnızca reset_lifecycle_file dosyasını içerdiğini ve bu dosyanın object SHA’sının önceki sürüme döndüğünü görüyoruz.

- Önemli nokta: git status, reset_lifecycle_file üzerinde değişiklikler olduğunu ve new_file adında izlenmeyen bir dosyanın bulunduğunu gösteriyor.

Bu, açıkça --mixed davranışıdır: Staging Index sıfırlanmıştır ve bekleyen değişiklikler Working Directory’ye taşınmıştır.

Karşılaştırmak gerekirse, --hard reset durumunda Staging Index sıfırlanmış ve Working Directory de sıfırlanmıştı; böylece değişiklikler kaybolmuştu.

### --soft 

--soft argümanı verildiğinde, sadece ref pointer’lar güncellenir ve reset burada durur. Staging Index ve Working Directory dokunulmadan bırakılır. Bu davranışı net bir şekilde göstermek zor olabilir. Demo repomuzla devam edelim ve soft reset için hazırlık yapalım. 

``` bash
$ git add reset_lifecycle_file 

 
$ git ls-files -s 

 
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file 

 
$ git status 

 
On branch main

 
Changes to be committed: 

 
(use "git reset HEAD ..." to unstage) 

 
modified: reset_lifecycle_file 

 
Untracked files: 

 
(use "git add ..." to include in what will be committed) 

 
new_file
``` 

Burada, değiştirilen reset_lifecycle_file dosyasını tekrar Staging Index’e eklemek için git add komutunu kullandık. git ls-files çıktısı ile indeksin güncellendiğini doğruladık. git status çıktısı artık yeşil renkle “Changes to be committed” bölümünü gösteriyor. Önceki örneklerden kalan new_file dosyası ise Working Directory’de untracked olarak duruyor. Yaklaşan örneklerde kullanmayacağımız için hızlıca rm new_file ile dosyayı sildik.

Depo bu durumda iken artık bir soft reset işlemi gerçekleştirebiliriz.

``` bash
$ git reset --soft
$ git status
On branch main
Changes to be committed:
    (use "git reset HEAD ..." to unstage)

modified: reset_lifecycle_file
$ git ls-files -s
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
``` 

Bir soft reset gerçekleştirdik. git status ve git ls-files ile depo durumunu incelediğimizde hiçbir değişiklik olmadığını görüyoruz. Bu beklenen bir davranıştır. Soft reset yalnızca Commit History’yi sıfırlar. Varsayılan olarak git reset çağrıldığında hedef commit HEAD’tir. Bizim Commit History zaten HEAD üzerinde olduğundan ve dolaylı olarak HEAD’e resetlediğimizden dolayı aslında hiçbir şey değişmedi.

--soft seçeneğini daha iyi anlamak ve kullanmak için HEAD olmayan bir hedef commit’e ihtiyacımız var. Şu anda Staging Index’te bekleyen reset_lifecycle_file var. Yeni bir commit oluşturalım. 

``` bash
$ git commit -m"prepend content to reset_lifecycle_file"
```  

Bu noktada, depomuzda üç commit olmalı. Zaman içinde ilk commit’e geri döneceğiz. Bunu yapmak için ilk commit’in ID’sine ihtiyacımız var. Bu ID’yi görmek için git log komutunun çıktısını inceleyebiliriz. 

``` bash
$ git log
commit 62e793f6941c7e0d4ad9a1345a175fe8f45cb9df
Author: bitbucket 
Date: Fri Dec 1 15:03:07 2017 -0800
prepend content to reset_lifecycle_file

commit dc67808a6da9f0dec51ed16d3d8823f28e1a72a
Author: bitbucket 
Date: Fri Dec 1 10:21:57 2017 -0800

update content of reset_lifecycle_file

commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4

Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800

initial commit
```  

Unutmayın ki Commit History ID’leri her sistemde benzersizdir. Yani bu örnekteki commit ID’leri, kişisel bilgisayarınızda gördüğünüz ID’lerden farklı olacaktır. Bu örnekte ilgilendiğimiz commit ID’si: 780411da3b47117270c0e3a8d5dcfd11d28d04a4 Bu ID, “initial commit”e karşılık gelmektedir. Bu ID’yi bulduktan sonra, soft reset için hedef olarak kullanacağız.

Zaman yolculuğuna çıkmadan önce, öncelikle deponun mevcut durumunu kontrol edelim. 

``` bash
$ git status && git ls-files -s
On branch main
nothing to commit, working tree clean
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
```   

Bir "soft reset" gerçekleştirdik. git status ve git ls-files ile repo durumunu incelediğimizde hiçbir şeyin değişmediğini görüyoruz. Bu beklenen bir durum. A soft reset sadece Commit History’yi resetler. Varsayılan olarak git reset, hedef commit olarak HEAD ile çalışır. Commit History zaten HEAD üzerinde olduğundan ve biz de HEAD’e reset yaptığımız için aslında hiçbir değişiklik olmadı.

--soft opsiyonunu daha iyi anlamak ve kullanmak için HEAD olmayan bir target commit’e ihtiyacımız var. Staging Index’te bekleyen reset_lifecycle_file dosyamız var. Şimdi yeni bir commit oluşturalım.

``` bash
$ git commit -m"prepend content to reset_lifecycle_file"
```  

Bu noktada, repo’muzda üç commit olmalı. Şimdi zamanda geriye, ilk commit’e gideceğiz. Bunu yapmak için ilk commit’in ID’sine ihtiyacımız olacak. Bu ID’yi git log çıktısını görüntüleyerek bulabiliriz.

``` bash
$ git log
commit 62e793f6941c7e0d4ad9a1345a175fe8f45cb9df
Author: bitbucket 
Date: Fri Dec 1 15:03:07 2017 -0800
prepend content to reset_lifecycle_file

commit dc67808a6da9f0dec51ed16d3d8823f28e1a72a
Author: bitbucket 
Date: Fri Dec 1 10:21:57 2017 -0800

update content of reset_lifecycle_file

commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4

Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800

initial commit
``` 

Unutmayın ki Commit History ID’leri her sistemde benzersizdir. Bu, bu örnekteki commit ID’lerinin kişisel makinenizde gördüklerinizden farklı olacağı anlamına gelir. Bu örnek için ilgilendiğimiz commit ID’si 780411da3b47117270c0e3a8d5dcfd11d28d04a4. Bu ID, “initial commit” ile eşleşir. Bu ID’yi bulduktan sonra, soft reset için hedef olarak kullanacağız.

Zamanda geriye gitmeden önce, repo’nun mevcut durumunu kontrol edelim.

``` bash
$ git status && git ls-files -s
On branch main
nothing to commit, working tree clean
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
``` 

Burada git status ve git ls-files -s komutlarını birleştirerek çalıştırıyoruz. Bu, repo’da bekleyen değişiklikler olduğunu ve Staging Index’teki reset_lifecycle_file dosyasının 67cc52710639e5da6b515416fd779d0741e3762e sürümünde olduğunu gösteriyor. Bunu göz önünde bulundurarak, şimdi soft reset ile ilk commit’imize geri dönelim.

``` bash
$ git status && git ls-files -s
On branch main
nothing to commit, working tree clean
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
```

Yukarıdaki kod, bir "soft reset" gerçekleştirir ve aynı zamanda git status ve git ls-files combo komutunu çalıştırır; bu komutlar repo’nun mevcut durumunu gösterir. Repo durumu çıktısını incelediğimizde bazı ilginç gözlemler yapabiliriz.

Birincisi, git status reset_lifecycle_file dosyasında değişiklikler olduğunu gösterir ve bunların bir sonraki commit için staged (hazır) değişiklikler olduğunu vurgular.

İkincisi, git ls-files çıktısı, Staging Index’in değişmediğini ve önceki gibi 67cc52710639e5da6b515416fd779d0741e3762e SHA’sını koruduğunu gösterir.

Bu reset sırasında neler olduğunu daha net görmek için git logu inceleyelim: 

``` bash
$ git log commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4 Author: bitbucket  Date: Thu Nov 30 16:50:39 2017 -0800 initial commit
```  

Log çıktısı artık Commit History’de tek bir commit olduğunu gösteriyor. Bu, --soft opsiyonunun ne yaptığını net bir şekilde gösterir. Tüm git reset çağrılarında, reset’in yaptığı ilk işlem commit ağacını resetlemektir. Önceki örneklerimizde --hard ve --mixed opsiyonlarıyla HEAD’e karşı çalışmıştık ve Commit Tree’yi geriye taşımamıştık. Soft reset sırasında ise sadece bu işlem gerçekleşir.

Bu durum, git status’un neden değiştirilmiş dosyalar gösterdiğini kafa karıştırıcı hale getirebilir. --soft Staging Index’e dokunmaz, bu yüzden Staging Index’teki güncellemeler commit geçmişinde geriye giderken bizimle birlikte taşınır. Bunu, git ls-files -s çıktısında reset_lifecycle_file dosyasının SHA’sının değişmediğini görerek doğrulayabiliriz.

Hatırlatma olarak, git status “üç ağaç”ın durumunu göstermez; esasen bunlar arasındaki farkı gösterir. Bu durumda, Staging Index’in Commit History’deki değişikliklerin önünde olduğunu ve sanki zaten stage’lenmiş gibi gösterdiğini görürüz. 