# OpenCV

### cv2.imread() metodu

OpenCV-Python, bilgisayarla görme (computer vision) görevlerini çözmek için kullanılan bir Python kütüphanesidir.
cv2.imread() yöntemi, belirtilen dosyadan bir görüntüyü yükler.

Eğer görüntü okunamazsa (örneğin dosya eksikse, dosyaya erişim izni yoksa veya görüntü formatı desteklenmiyorsa/geçerli değilse) o zaman boş bir matris (resim) döndürür.

örnek:
```python

import cv2
image = cv2.imread("gfg.jpeg")

cv2.imshow("Image", image)

cv2.waitKey(0)
cv2.destroyAllWindows()
```  


<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230515154710/gfg.jpeg" width="300">
</p>


**cv2.imread(filename, flag) 2 parametre alıyor:**

Parametreler:

**filename:**
Görüntü dosyasının yolunu belirtir.

**flag:**
Görüntünün nasıl okunacağını belirtir. Şu seçenekler kullanılabilir:

**cv2.IMREAD_COLOR**  
Renkli bir görüntü yüklemeyi belirtir. Görüntünün şeffaflık (alpha) bilgisi yok sayılır.
Bu varsayılan (default) bayraktır.
Alternatif olarak bu bayrak için 1 sayısı kullanılabilir.

**cv2.IMREAD_GRAYSCALE**  
Görüntünün gri tonlamalı olarak yüklenmesini belirtir.
Alternatif olarak 0 sayısı kullanılabilir.

**cv2.IMREAD_UNCHANGED**  
Görüntünün alpha kanalı dahil tam hâliyle yüklenmesini belirtir.
Alternatif olarak -1 sayısı kullanılabilir.

Gri tonda resim okuma:

``` python 

import cv2

image = cv2.imread("gfg.jpeg",cv2.IMREAD_GRAYSCALE)

cv2.imshow("Image", image)

cv2.waitKey(0)
cv2.destroyAllWindows() 
```

çıktı: 
<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230515154850/gfggray.png" width="300">
</p>

Saydamlık (Transparency) İçeren PNG Görüntüsünü Okuma:

Her pikselin ne kadar saydam veya ne kadar dolu (katı) olduğunu kontrol eder:

- 0 değeri → tamamen saydam (görünmez)

- 255 değeri → tamamen opak (katı) 

``` python

import cv2
image = cv2.imread("gfg.jpeg",cv2.IMREAD_UNCHANGED)

cv2.imshow("Image", image)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

çıktı: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230515154954/gfgunchanged.png" width="300">
</p> 

### cv2.imshow() metodu 

cv2.imshow() yöntemi, bir görüntüyü bir pencerede göstermek için kullanılır.
Pencere, görüntünün boyutuna göre otomatik olarak ayarlanır. 

***cv2.imshow(window_name, image)***

Parametreler:

***window_name:***
Görüntünün gösterileceği pencerenin adını temsil eden bir string.

***image:***
Gösterilecek olan görüntü.

**Dönüş Değeri (Return Value):**

Herhangi bir değer döndürmez.

örnek:
``` python

import cv2


image = cv2.imread("resim.png")

window_name = 'image'

cv2.imshow(window_name, image)

cv2.waitKey(0)

cv2.destroyAllWindows()
``` 

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190802022327/Annotation-2019-08-02-022111.png" width="300" height=200>
</p> 

örnek:

```python

import cv2


image = cv2.imread("resim.png", 0)

window_name = 'image'

cv2.imshow(window_name, image)

cv2.waitKey(0)

cv2.destroyAllWindows()
```

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190802022316/Annotation-2019-08-02-022133.png" width="300" height=200>
</p> 


### cv2.imwrite() metodu

**cv2.imwrite()**

Bu yöntem, bir görüntüyü herhangi bir depolama aygıtına kaydetmek için kullanılır.
Görüntü, belirtilen formata göre geçerli çalışma dizinine (current working directory) kaydedilir. 


**cv2.imwrite(filename, image)**

Parametreler:

**filename:**
Dosya adını temsil eden bir string.
Dosya adının .jpg, .png gibi bir görüntü formatı içermesi gerekir.

**image:**
Kaydedilecek olan görüntü.

**Dönüş Değeri (Return Value):**

Görüntü başarıyla kaydedilirse True, kaydedilemezse False döndürür. 

örnek:

``` python 
 
import cv2
import os

resim_yolu = "arabamdacia.png"
klasor = os.getcwd()

resim = cv2.imread(resim_yolu)
if resim is None:
    print("Resim bulunamadı.")
    exit()

print("Kaydetmeden önce:", os.listdir(klasor))

dosya_adi = "kayitli_resim.jpg"
cv2.imwrite(dosya_adi, resim)

print("Kaydettikten sonra:", os.listdir(klasor))
print("Resim kaydedildi!")
```

### waitKey() fonksiyonu


Python OpenCV'nin waitKey() fonksiyonu, bir pencerenin belirli bir süre boyunca açık kalmasına veya bir tuşa basılana kadar beklemesine olanak tanır.
Fonksiyon, parametre olarak milisaniye cinsinden süre alır ve bu süre boyunca bekler.
Eğer argüman olarak 0 verilirse, herhangi bir tuşa basılana kadar bekler.

örnek: 
``` python 

import cv2
img = cv2.imread("gfg_logo.png")

cv2.imshow('gfg', img)
cv2.waitKey(5000)
cv2.destroyAllWindows()
```
çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20210927164556/ezgif144cd69b1c0ed.gif" width="300" height=200>
</p>


Açıklama (Explanation):

- **cv2.imread("gfg_logo.png")**  
Görüntüyü dosyadan bir değişkene (img) NumPy array olarak yükler.

- **cv2.imshow('gfg', img)**  
Yüklenen görüntüyü "gfg" başlıklı bir pencerede gösterir.

- **cv2.waitKey(5000) + cv2.destroyAllWindows()**  
5 saniye bekler, ardından görüntü penceresini otomatik olarak kapatır.

**cv2.waitKey([delay])**

Parametre:

**delay (Opsiyonel / Optional):**  
Bir tuş olayını beklemek için milisaniye cinsinden süreyi belirtir.

Eğer 0 verilirse, süresiz bekler (herhangi bir tuşa basılana kadar).

**Dönüş Değeri (Returns):**  

Basılan tuşun ASCII kodunu döndürür.

Eğer verilen süre içinde hiçbir tuşa basılmazsa, -1 döndürür.



**cv2.waitKey() Kullanım Alanları**


Tuş basılana kadar süresiz bekleme:
cv2.waitKey(0) komutu, bir tuşa basılana kadar programı duraklatır.
Genellikle statik görüntüleri gösterirken, pencerenin kullanıcı bir tuşa basana kadar açık kalmasını sağlamak için kullanılır.

``` 
cv2.waitKey(0)
```

Sınırlı süre için tuş bekleme:
cv2.waitKey(milliseconds) komutu, belirtilen süre (milisaniye cinsinden) boyunca bekler.
Süre dolduğunda veya bir tuşa basıldığında program devam eder.
Bu kullanım video oynatma, animasyonlar veya slayt gösterileri için idealdir.

```
cv2.waitKey(1000)  # 1000 ms = 1 saniye bekler
```

Örnek 1:

Bu örnek, OpenCV kullanarak bir görüntüyü yükler ve gösterir, ardından kullanıcı herhangi bir tuşa basana kadar süresiz bekler.

```python
import cv2

img = cv2.imread("gfg_logo.png")
cv2.imshow('gfg', img)
cv2.waitKey(0)
```

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20210927164700/ok.gif" width="300" height=200>
</p> 

Açıklama:

- **cv2.imread()**   görüntüyü img değişkenine yükler ve cv2.imshow() görüntüyü bir pencerede gösterir.  
- **cv2.waitKey(0)**   tuşa basılmasını süresiz olarak bekler ve cv2.destroyAllWindows() pencereyi kapatır.

Örnek 2: Bu örnek, bir videoyu (video.mp4) kare kare OpenCV ile oynatır. Her kareyi gerçek zamanlı olarak görüntüler ve kullanıcı 'q' tuşuna basarak oynatmayı durdurabilir.

``` PYTHON
import cv2

cap = cv2.VideoCapture('video.mp4')

while True:
    ret, frame = cap.read()
    if not ret:
        break

    cv2.imshow('Video Playback', frame)

    # wait 25ms and check if 'q' is pressed to quit
    if cv2.waitKey(25) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250605112553029567/output.gif" width="300" height=200>
</p> 

Açıklama:

- **cv2.VideoCapture() + cap.read()** video dosyasını açar ve kareleri döngü içinde teker teker okur.  
- **cv2.imshow() + cv2.waitKey(25)** her kareyi gösterir ve kareler arasında 25 ms bekler (gerçek zamanlı oynatma için).
- Eğer 'q' tuşuna basılırsa döngüden çıkılır, video serbest bırakılır ve tüm pencereler kapatılır.

### OpenCV’de Renk Uzayları Arasında Dönüşüm

Renk Uzayları — Neden Önemli?

“Color space / color model” terimi, bir imgedeki renklerin nasıl temsil edildiğini tanımlar. Yani her pikseldeki renk, belli sayıda “kanal” (mesela kırmızı, yeşil, mavi) kullanılarak saklanır. 


Farklı renk uzayları, renk, aydınlık/ışık ve ton gibi bilgileri farklı şekillerde ayırır. Bu da görüntü işleme, renk filtresi, segmentasyon, nesne tespiti gibi görevlerde çok önemli. 

| Renk Uzayı | Anlamı / Kanal Yapısı | Ne İçin Kullanılır / Avantajı |
|------------|----------------------|------------------------------|
| **RGB** (Red, Green, Blue) | Her piksel kırmızı, yeşil ve mavi kanal değerleriyle tanımlanır. | Ekranda görüntüleme, temel renk uzayı. |
| **BGR** (Blue, Green, Red) | OpenCV’nin varsayılan renk sırası — R ve B yer değişmiş. | OpenCV’de okunan resimleri doğru yorumlamak için. |
| **HSV** (Hue, Saturation, Value) | Hue: renk türü, Saturation: doygunluk, Value: parlaklık. | Renk tespiti, segmentasyon, ışığa dayanıklı renk filtreleme. |
| **LAB** (Lightness, A, B) | L: parlaklık, A/B: renk bileşenleri. | Renk iyileştirme, insan gözüne daha yakın renk analizi. |
| **Grayscale (Gri Ton)** | Tek kanal: yalnızca parlaklık değeri. | Kenar bulma, şekil analizi, hızlı görüntü işleme. |


**Renk Uzayları Arası Dönüşüm — cv2.cvtColor()**

OpenCV’de bir image’i (resmi) bir renk uzayından diğerine çevirmek için **cv2.cvtColor** fonksiyonu kullanılır.

``` python
import cv2

img = cv2.imread("resim.jpg")  # varsayılan: BGR

# BGR → RGB
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# BGR → HSV
img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# BGR → Grayscale (gri ton)
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# BGR → LAB
img_lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
```

Bu dönüşüm, görüntü işleme ve analiz için renk bilgisini uygun hale getirir. 

Örneğin:

Renk tespiti & segmentasyon için **HSV**

Işık/parlaklık analizi ya da renk düzeltme için ***LAB***

Basit görüntü işleme / kontur/kenar tespiti vs. için **Gri-ton**

Ne Zaman Hangi Renk Uzayı?

Ekranda gösterim / normal resim işlemleri → **BGR / RGB**

Renk bazlı işlemler, renk tespiti, maskeleme → **HSV**

Işık / parlaklık / kontrast / renk düzeltme → **LAB**

Renk önemsiz, şekil/kenar/morfoloji işlemleri → **Grayscale**

### Aritmetik İşlemler ve Bit Düzeyinde İşlemler

Toplama (addition), çıkarma (subtraction) ve bit düzeyinde işlemler (AND, OR, NOT, XOR) gibi aritmetik işlemler, OpenCV ile görüntü işleme için temel tekniklerdir.

Bu işlemler, görüntü özelliklerini geliştirmek, analiz etmek ve dönüştürmek için kullanılır. Bu nedenle, görüntü netleştirme (clarification), eşikleme (thresholding), genişletme (dilation) gibi görevlerde oldukça önemlidir. 

Aritmetik işlemlerin adım adım uygulanışını:

Adım 1: Gerekli Kütüphaneleri Yükleme ve Paketleri İçe Aktarma

- opencv-python (cv2): Görüntü işleme ve bilgisayarla görme için temel kütüphane.

- matplotlib.pyplot: Görüntüleri Jupyter Notebook veya benzeri ortamlarda göstermek için kullanılır.

- numpy: Diziler üzerinde hızlı ve verimli işlem yapmak için kullanılır.

``` python

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
```

Adım 2: Giriş Görüntülerini Yükleme

- files.upload(): Cihazımızdan dosya seçmek için bir diyalog açar (genellikle Google Colab için).

- cv2.imread(): Diskten bir görüntüyü okur ve NumPy dizisi olarak yükler (varsayılan olarak BGR renk sıralamasıyla).

``` python 
img1 = cv2.imread('input1.png')
img2 = cv2.imread('input2.png')
```

Adım 3: Giriş Görüntülerini Görselleştirme 

``` python
if img1.shape != img2.shape:
    img2 = cv2.resize(img2, (img1.shape[1], img1.shape[0]))

line_thickness = 5
height = img1.shape[0]
line = np.full((height, line_thickness, 3), (0, 0, 255), dtype=np.uint8)

side_by_side = np.hstack((img1, line, img2))

side_by_side_rgb = cv2.cvtColor(side_by_side, cv2.COLOR_BGR2RGB)

plt.figure(figsize=(12, 6))
plt.imshow(side_by_side_rgb)
plt.title('input1 input2')
plt.axis('off')
plt.show()
```

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155108661934/sidebyside.webp"height=200>
</p>

Adım 4: İşlemleri Gerçekleştirme

1. Görüntü Toplama (Image Addition)  
1.1.  Basit Toplama (Simple Addition)

    cv2.add(): İki görüntünün piksel değerlerini toplar ve taşma durumunda (255’i aşarsa) doygunluk uygular. 

    ``` python
    added = cv2.add(img1, img2)
    added_rgb = cv2.cvtColor(added, cv2.COLOR_BGR2RGB)

    plt.imshow(added_rgb)
    plt.title('Addition (cv2.add)')
    plt.axis('off')
    plt.show()
    ``` 

    çıktı:
    <p align="center">
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155109213959/simpleadd.webp"height=200>
    </p> 

    1.2 Ağırlıklı Toplama

    cv2.addWeighted(): İki görüntüyü belirli ağırlıklarla karıştırır ve isteğe bağlı bir skaler (gamma) ile parlaklığı ayarlayabilir.

    Parametreler:

    - img1, img2: İşlem yapılacak giriş görüntüleri

    - 0.7, 0.3: Her görüntünün katkı oranı (weight)

    - 0: Gamma değeri (parlaklık ayarı)

    ``` python
    weighted = cv2.addWeighted(img1, 0.7, img2, 0.3, 0)
    weighted_rgb = cv2.cvtColor(weighted, cv2.COLOR_BGR2RGB)

    plt.imshow(weighted_rgb)
    plt.title('Weighted Addition (cv2.addWeighted)')
    plt.axis('off')
    plt.show()
    ```
    çıktı:
<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155109022835/weightadd.webp"height=200>
</p> 

2. Görüntü Çıkarma (Image Subtraction)

    - cv2.subtract(): img1’deki her pikselden img2’deki karşılık gelen pikseli çıkarır.

    - Negatif değerler 0 olarak sınırlandırılır (clipping).

    Kullanım Alanları:

    - Değişiklik tespiti (change detection)

    - Arka plan çıkarma (background subtraction)

     - Görüntü farklılıklarını vurgulama

    ``` python
    subtracted = cv2.subtract(img1, img2)
    subtracted_rgb = cv2.cvtColor(subtracted, cv2.COLOR_BGR2RGB)

    plt.imshow(subtracted_rgb)
    plt.title('Subtraction (cv2.subtract)')
    plt.axis('off')
    plt.show()
    ```
<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155108016952/substraction.webp"height=200>
</p> 

3. Bit Düzeyinde İşlemler (Bitwise Operations)  
    3.1 Bitwise AND

    - cv2.bitwise_and(): Sadece iki görüntüde de pikseller “1” (aktif) olduğunda o piksel değerini korur.

    - Genellikle maske uygulama veya belirli bölgeleri izole etmek için kullanılır.

    ``` python 
    and_img = cv2.bitwise_and(img1, img2)
    and_img_rgb = cv2.cvtColor(and_img, cv2.COLOR_BGR2RGB)

    plt.imshow(and_img_rgb)
    plt.title('Bitwise AND')
    plt.axis('off')
    plt.show()
    `````

    çıktı: 

    <p align="center">
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155108372893/bitwise-and.webp"height=200>
    </p> 

    3.2 Bitwise OR

    - cv2.bitwise_or(): Piksel değerlerini korur eğer iki görüntüden herhangi birinde bit “1” (aktif) ise.

    - İki görüntüdeki aktif bölgeleri birleştirmek için kullanılır.

    ``` PYTHON
    or_img = cv2.bitwise_or(img1, img2)
    or_img_rgb = cv2.cvtColor(or_img, cv2.COLOR_BGR2RGB)

    plt.imshow(or_img_rgb)
    plt.title('Bitwise OR')
    plt.axis('off')
    plt.show()
    ```

    çıktı:   
    <p align="center">
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155108295476/bitwise-or.webp"height=200>
    </p> 

    3.3 Bitwise XOR

    - cv2.bitwise_xor(): Piksel değerlerini sadece bir görüntüde aktif, diğerinde değilse korur.

    - Yani iki görüntüde de aynı piksel aktifse o piksel sonuçta silinecek.


    ``` python
    xor_img = cv2.bitwise_xor(img1, img2)
    xor_img_rgb = cv2.cvtColor(xor_img, cv2.COLOR_BGR2RGB)

    plt.imshow(xor_img_rgb)
    plt.title('Bitwise XOR')
    plt.axis('off')
    plt.show()
    ``` 
    çıktı:

    <p align="center">
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155108216773/bitwise-xor.webp"height=200>
    </p> 

    3.4 Bitwise NOT

    - cv2.bitwise_not(): Tek bir görüntüyü tersler (invert).

    - Yani 0 → 255 ve 255 → 0 olur.

    - Kullanım alanı: Maskeleri terslemek, negatif görüntü elde etmek veya bazı efektler yapmak. 

    ``` python 
    not_img = cv2.bitwise_not(img1)
    not_img_rgb = cv2.cvtColor(not_img, cv2.COLOR_BGR2RGB)

    plt.imshow(not_img_rgb)
    plt.title('Bitwise NOT (Image 1)')
    plt.axis('off')
    plt.show()
    ``` 
    çıktı:   
    <p align="center">
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250802155108138812/bitwise-not.webp"height=200>
    </p>


### OPenCV kullanarak resim bulanıklaştırma 

Bulanıklaştırma bir görüntünün keskinliğini azaltıp daha yumuşak görünmesini sağlayan işlemdir.  

Genelde:

- Gürültü azaltmak

- Detayları yumuşatmak

- Kenar algılama öncesi hazırlık

için kullanılır.

.

OpenCV’de Kullanılan Blurring Türleri:   
1. Averaging (Box Blur)

Piksel değerlerini ortalayarak bulanıklaştırır.

Kod:
``` python
blur = cv2.blur(img, (5,5))
``` 


2. Gaussian Blur

Gaussian dağılımı kullanır → daha doğal, gerçekçi bir bulanıklık.

Kod:
``` python
gauss = cv2.GaussianBlur(img, (5,5), 0)
```  
3. Median Blur

Her pikseli komşuların medyan değeriyle değiştirir.

Kod:
``` python
median = cv2.medianBlur(img, 5)
``` 

4. Bilateral Filter

Hem mekânsal uzaklığı hem renk farkını hesaba katar.;

Kod:
``` python
bilateral = cv2.bilateralFilter(img, 15, 75, 75)
``` 

### Hangi Durumda Hangisi?

| Amaç                                    | Kullanılması Gereken Blur |
|-----------------------------------------|---------------------------|
| Basit ve hızlı bulanıklaştırma          | Averaging (cv2.blur)      |
| Daha doğal blur + gürültü azaltma       | Gaussian (cv2.GaussianBlur) |
| Nokta gürültüsü (salt-pepper) temizleme | Median (cv2.medianBlur)   |
| Kenarları koruyarak blur                | Bilateral (cv2.bilateralFilter) |

örnek: 

``` python
import cv2

img = cv2.imread("resim.jpg")

blur = cv2.blur(img, (5,5))
gauss = cv2.GaussianBlur(img, (5,5), 0)
median = cv2.medianBlur(img, 5)
bilateral = cv2.bilateralFilter(img, 15, 75, 75)
``` 
### OpenCV ile Görüntüleri Gri Tonlara Çevirme


**OpenCV ile Grayscaling — Yöntemler**

Yöntem 1 — cv2.cvtColor() ile dönüşüm 

``` python
import cv2

img = cv2.imread("resim.jpg")  # OpenCV varsayılan: BGR
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

cv2.imshow("Gri-ton", gray)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

- cv2.cvtColor(src, cv2.COLOR_BGR2GRAY) ile renkli resmi gri-tona çevirir. 

Yöntem 2 — cv2.imread() ile direkt gri olarak okuma

``` python
import cv2

gray = cv2.imread("resim.jpg", 0)  # 0 = grayscale flag

cv2.imshow("Gri-ton", gray)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

- cv2.imread(..., 0) ile resmi direk gri-ton (tek kanal) olarak yükleyebilirsin — ayrıca cvtColor kullanmaya gerek kalmaz. 

**Alternatif: El ile piksel bazlı gri ton hesaplama**

Renkli resim piksellerini manuel olarak gri değere çevirme — genelde iki yol:

- Ortalama alma (average): (R + G + B)/3

- Ağırlıklı ortalama (luminance): genelde insan gözü duyarlılığına göre 0.2989 R + 0.5870 G + 0.1140 B

``` python
for i in range(rows):
    for j in range(cols):
        gray = 0.2989*R + 0.5870*G + 0.1140*B
        img[i, j] = [gray, gray, gray]
```

Bu yöntemler teorik olarak çalışır ama hem yavaş hem de genelde cvtColor kadar doğru / pratik değil.

Hangisi Ne Zaman Kullanılır?

| Durum                              | Kullanılacak Yöntem                  |
|----------------------------------------------|---------------------------------------|
| Sadece gri-ton resim yeterliyse              | `cv2.imread("resim.jpg", 0)`          |
| Renkli resmi griye dönüştürmen gerekiyorsa   | `cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)` |
| Kenar bulma, threshold, blur gibi işlemler   | Önce `gray` görüntü kullanılır        |
| Daha az RAM ve daha hızlı yükleme gerekiyorsa| Direkt gri okuma (`imread(..., 0)`)   |
| Renkli görüntü üzerinde çalışıyorsan         | `cvtColor` ile griye dönüştür         |

### Ölçekleme, Döndürme, Kaydırma ve Kenar Algılama 

1. Görüntü Yeniden Boyutlandırma (Image Resizing)

Görüntü yeniden boyutlandırma, bir görüntünün boyutlarını değiştirme işlemidir.
Bu işlem görüntüyü büyütme veya küçültme şeklinde olabilir ve içerik korunur.

OpenCV’de bunun için:

- cv2.resize() → görüntüyü yeni boyutlara göre yeniden boyutlandırır

- cv2.INTER_CUBIC → yüksek kalite büyütme

- cv2.INTER_AREA → küçültme için en iyi sonuç

Kod:

``` python
import cv2
import numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('Ganeshji.webp')
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
scale_factor_1 = 3.0  
scale_factor_2 = 1/3.0
height, width = image_rgb.shape[:2]
new_height = int(height * scale_factor_1)
new_width = int(width * scale_factor_1)

zoomed_image = cv2.resize(src =image_rgb, 
                          dsize=(new_width, new_height), 
                          interpolation=cv2.INTER_CUBIC)
                          
new_height1 = int(height * scale_factor_2)
new_width1 = int(width * scale_factor_2)
scaled_image = cv2.resize(src= image_rgb, 
                          dsize =(new_width1, new_height1), 
                          interpolation=cv2.INTER_AREA)

fig, axs = plt.subplots(1, 3, figsize=(10, 4))
axs[0].imshow(image_rgb)
axs[0].set_title('Original Image Shape:'+str(image_rgb.shape))
axs[1].imshow(zoomed_image)
axs[1].set_title('Zoomed Image Shape:'+str(zoomed_image.shape))
axs[2].imshow(scaled_image)
axs[2].set_title('Scaled Image Shape:'+str(scaled_image.shape))

for ax in axs:
    ax.set_xticks([])
    ax.set_yticks([])

plt.tight_layout()
plt.show()
```

çıktı: 

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717131132/Ganesh-2.webp"height=200>
</p>

2. Görüntü Döndürme:

Görüntüler saat yönünde veya tersinde belirli bir açıyla döndürülebilir.

Kullanılan fonksiyonlar:

- cv2.getRotationMatrix2D() → döndürme matrisini üretir

- cv2.warpAffine() → döndürmeyi uygular

- Pozitif açı → saat yönünde

- Negatif açı → saat yönünün tersinde

Kod:

``` python
import cv2
import matplotlib.pyplot as plt
img = cv2.imread('Ganeshji.webp')
image_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
center = (image_rgb.shape[1] // 2, image_rgb.shape[0] // 2)
angle = 30
scale = 1
rotation_matrix = cv2.getRotationMatrix2D(center, angle, scale)
rotated_image = cv2.warpAffine(image_rgb, rotation_matrix, (img.shape[1], img.shape[0]))

fig, axs = plt.subplots(1, 2, figsize=(7, 4))
axs[0].imshow(image_rgb)
axs[0].set_title('Original Image')
axs[1].imshow(rotated_image)
axs[1].set_title('Image Rotation')
for ax in axs:
    ax.set_xticks([])
    ax.set_yticks([])
    
plt.tight_layout()
plt.show()
``` 

çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717131308/Ganesh-3.webp"height=200>
</p>

3. Görüntü Kaydırma:

Görüntünün X ve Y eksenlerinde başka bir konuma taşınmasıdır.
Bu işlem görüntü içeriğini bozmaz, sadece konumu değişir.

- tx, ty → yatay ve dikey kaydırma

- cv2.warpAffine() → kaydırmayı uygular

Kod: 

``` python
import cv2
import matplotlib.pyplot as plt
import numpy as np

img = cv2.imread('Ganeshji.webp')
image_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
width, height = image_rgb.shape[1], image_rgb.shape[0]

tx, ty = 100, 70
translation_matrix = np.array([[1, 0, tx], [0, 1, ty]], dtype=np.float32)
translated_image = cv2.warpAffine(image_rgb, translation_matrix, (width, height))

fig, axs = plt.subplots(1, 2, figsize=(7, 4))
axs[0].imshow(image_rgb), axs[0].set_title('Original Image')
axs[1].imshow(translated_image), axs[1].set_title('Image Translation')

for ax in axs:
    ax.set_xticks([]), ax.set_yticks([])

plt.tight_layout()
plt.show()
``` 

çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717131431/Ganesh-4.webp"height=200>
</p>

4. Görüntü Kesme/Eğme (Image Shearing)

Shearing, görüntüyü bir tarafa doğru eğerek "kaymış" gibi görünmesini sağlar.

- shearX, shearY → eğme miktarı

- cv2.warpAffine() → uygular

Kod:
``` python 
import cv2
import numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('Ganeshji.webp')
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
width, height = image_rgb.shape[1], image_rgb.shape[0]

shearX, shearY = -0.15, 0
transformation_matrix = np.array([[1, shearX, 0], [0, 1, shearY]], dtype=np.float32)
sheared_image = cv2.warpAffine(image_rgb, transformation_matrix, (width, height))

fig, axs = plt.subplots(1, 2, figsize=(7, 4))
axs[0].imshow(image_rgb), axs[0].set_title('Original Image')
axs[1].imshow(sheared_image), axs[1].set_title('Sheared Image')

for ax in axs:
    ax.set_xticks([]), ax.set_yticks([])

plt.tight_layout()
plt.show()
```

çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717131550/Ganesh-5.webp"height=200>
</p>

5. Görüntü Normalizasyonu (Image Normalization)

Normalizasyon, piksel değerlerini 0–1 gibi belirli bir aralığa ölçeklendirir.

- cv2.normalize() → pikselleri normalize eder

- cv2.NORM_MINMAX → 0 ile 1 arasında sıkıştırır

- cv2.merge() → normalize edilmiş kanalları birleştirir

Kod:

``` python
import cv2
import numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('Ganeshji.webp')
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
b, g, r = cv2.split(image_rgb)

b_normalized = cv2.normalize(b.astype('float'), None, 0, 1, cv2.NORM_MINMAX)
g_normalized = cv2.normalize(g.astype('float'), None, 0, 1, cv2.NORM_MINMAX)
r_normalized = cv2.normalize(r.astype('float'), None, 0, 1, cv2.NORM_MINMAX)

normalized_image = cv2.merge((b_normalized, g_normalized, r_normalized))
print(normalized_image[:, :, 0])

plt.imshow(normalized_image)
plt.xticks([]); plt.yticks([])
plt.title('Normalized Image')
plt.show()
```
çıktı:
```
[[0.0745098  0.0745098  0.0745098  ... 0.07843137 0.07843137 0.07843137]
 [0.0745098  0.0745098  0.0745098  ... 0.07843137 0.07843137 0.07843137]
 [0.0745098  0.0745098  0.0745098  ... 0.07843137 0.07843137 0.07843137]
 ...
 [0.00392157 0.00392157 0.00392157 ... 0.0745098  0.0745098  0.0745098 ]
 [0.00392157 0.00392157 0.00392157 ... 0.0745098  0.0745098  0.0745098 ]
 [0.00392157 0.00392157 0.00392157 ... 0.0745098  0.0745098  0.0745098 ]]

```
<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717131716/Ganesh-6.webp"height=200>
</p>


6. Kenar Tespiti (Edge Detection)

Kenar tespiti, görüntüdeki nesne sınırlarını bulmak için kullanılır.

- cv2.GaussianBlur() → gürültüyü azaltır

- cv2.Sobel() → gradyanı hesaplar

- cv2.Canny() → en yaygın kenar bulucu

Kod:

``` python
import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('Ganeshji.webp')
image_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
edges = cv2.Canny(image_rgb, 100, 700)

fig, axs = plt.subplots(1, 2, figsize=(7, 4))
axs[0].imshow(image_rgb), axs[0].set_title('Original Image')
axs[1].imshow(edges), axs[1].set_title('Image Edges')

for ax in axs:
    ax.set_xticks([]), ax.set_yticks([])

plt.tight_layout()
plt.show()
```
çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717131823/Ganesh-7.webp"height=200>
</p>


7. Görüntü Bulanıklaştırma (Image Blurring)

Bulanıklaştırma, pikselleri ortalama alarak görüntüyü yumuşatır.

- cv2.GaussianBlur() → en yaygın blur

- cv2.medianBlur() → tuz-biber gürültüsüne karşı iyi

- cv2.bilateralFilter() → kenarları korurken blur yapar

Kod:

``` python
import cv2
import numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('Ganeshji.webp')
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
blurred = cv2.GaussianBlur(image, (3, 3), 0)
blurred_rgb = cv2.cvtColor(blurred, cv2.COLOR_BGR2RGB)

fig, axs = plt.subplots(1, 2, figsize=(7, 4))
axs[0].imshow(image_rgb), axs[0].set_title('Original Image')
axs[1].imshow(blurred_rgb), axs[1].set_title('Blurred Image')

for ax in axs:
    ax.set_xticks([]), ax.set_yticks([])

plt.tight_layout()
plt.show()
``` 

çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717131949/Ganesh-8.webp"height=200>
</p>
  

8. Morfolojik İşlemler (Morphological Operations)

Görüntüdeki şekilleri/gövdeleri düzenlemek için yapılır.

- cv2.dilate() → genişletir

- cv2.erode() → daraltır

- cv2.MORPH_OPEN → küçük gürültüleri temizler

- cv2.MORPH_CLOSE → küçük boşlukları doldurur

Kod:
``` python
import cv2
import numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('Ganeshji.webp')
image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
kernel = np.ones((3, 3), np.uint8)

dilated = cv2.dilate(image_gray, kernel, iterations=2)
eroded = cv2.erode(image_gray, kernel, iterations=2)
opening = cv2.morphologyEx(image_gray, cv2.MORPH_OPEN, kernel)
closing = cv2.morphologyEx(image_gray, cv2.MORPH_CLOSE, kernel)

fig, axs = plt.subplots(2, 2, figsize=(7, 7))
axs[0, 0].imshow(dilated, cmap='Greys'), axs[0, 0].set_title('Dilated Image')
axs[0, 1].imshow(eroded, cmap='Greys'), axs[0, 1].set_title('Eroded Image')
axs[1, 0].imshow(opening, cmap='Greys'), axs[1, 0].set_title('Opening')
axs[1, 1].imshow(closing, cmap='Greys'), axs[1, 1].set_title('Closing')

for ax in axs.flatten():
    ax.set_xticks([]), ax.set_yticks([])

plt.tight_layout()
plt.show()
``` 
çıktı: 

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230717132101/Ganesh-9.webp"width = 300 height=200>
</p> 

### Bir Görüntüyü Bir Renk Uzayından Diğerine Dönüştürme 

cv2.cvtColor() — OpenCV’de Renk Uzayı Dönüştürme

**cv2.cvtColor()** fonksiyonu, bir görüntüyü bir renk uzayından başka bir renk uzayına dönüştürmek için kullanılır.

OpenCV’de 150’den fazla renk dönüşüm kodu vardır ama pratikte en çok kullanılanlar:

- BGR → GRAY

- BGR → RGB

- BGR → HSV

Neden Renk Uzayı Değiştirilir

Bazı işlerde farklı türde görüntü formatı gerekir:

- Grayscale (Gri tonlama)

Hesaplamayı hafifletir

Kenar tespiti, yüz tanıma, eşikleme gibi işlemlerin çoğu gri tonlamada yapılır

- HSV (Hue – Saturation – Value)

Renk takibi (ör. eldiven, top, yüz tespiti) için çok iyidir

RGB’ye göre daha stabil renk analizi sağlar

- LAB, YCrCb

Cilt tespiti

White balance

Görüntü iyileştirme

**cv2.cvtColor(src, code[, dst[, dstCn]])**

Parametreler:

- src → çevrilecek olan görüntü

- code → dönüşüm kodu (örn. cv2.COLOR_BGR2GRAY)

- dst → (opsiyonel) çıktı

- dstCn → (opsiyonel) kanal sayısı

OpenCV görüntüleri BGR formatında okur, RGB değil.

Matplotlib ile gösterirken BGR → RGB dönüşümü yapılmalıdır.

Kaynağa uygun dönüşüm kodu seçmek gerekir.

ÖRNEKLER:

Örnek 1: BGR → Grayscale Dönüştürme

``` python
import cv2

src = cv2.imread('logo.png')

gray_image = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)

cv2.imshow("Grayscale Image", gray_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20191011105437/grayscale_output.png"width = 300 height=200>
</p>

Açıklama:

- **cv2.COLOR_BGR2GRAY**: Gri tonlamaya çevirir

- **cv2.imshow()**: Görüntüyü gösterir

- **cv2.waitKey(0)**: Bir tuşa basana kadar bekler

Örnek 2: BGR → HSV Dönüştürme

``` python
import cv2

src = cv2.imread('logo.png')

hsv_image = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)

cv2.imshow("HSV Image", hsv_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
``` 
çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20191011105459/HSV_output.png"width = 300 height=200>
</p>

Kullanım Alanı:

- Renk takibi

- Nesne segmentasyonu

Örnek 3: BGR → RGB (Matplotlib için)

``` python
import cv2
import matplotlib.pyplot as plt

src = cv2.imread('logo.png')

rgb_image = cv2.cvtColor(src, cv2.COLOR_BGR2RGB)

plt.imshow(rgb_image)
plt.title("RGB Image for Matplotlib")
plt.axis('off')
plt.show()
```

çıktı:

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20250811163116896952/rgbImage_output.png"width = 300 height=200>
</p> 

Neden gerekli?

- Matplotlib RGB formatı bekler

- OpenCV BGR formatı kullanır

Sık Kullanılan Dönüşüm Kodları:

| OpenCV Kodları            | Açıklama                         |
|---------------------------|-----------------------------------|
| `cv2.COLOR_BGR2GRAY`      | BGR → Grayscale (gri ton)         |
| `cv2.COLOR_BGR2RGB`       | BGR → RGB                         |
| `cv2.COLOR_BGR2HSV`       | BGR → HSV                         |
| `cv2.COLOR_BGR2LAB`       | BGR → LAB renk uzayı              |
| `cv2.COLOR_BGR2YCrCb`     | BGR → YCrCb (cilt tespiti vb.)    |


### cv2.copyMakeBorder() metodu 


**cv2.copyMakeBorder()** fonksiyonu, bir görüntünün etrafına kenarlık eklememizi sağlar.
Bu, görüntü dolgusu (padding), çerçeve oluşturma veya makine öğrenimi için görüntü hazırlama gibi çeşitli görüntü işleme görevlerinde faydalıdır.

Basit bir örnek:

``` python
import cv2
from google.colab.patches import cv2_imshow

image = cv2.imread("/content/geeks14.png")
image = cv2.copyMakeBorder(image, 10, 10, 10, 10,
                           cv2.BORDER_CONSTANT, None, value=0)

print(window_name)
cv2_imshow(image)
``` 

Çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250805171633603246/b1.webp" width="200">
</p>


**cv2.copyMakeBorder(src, top, bottom, left, right, borderType, value)**

Parametreler:

- src: Kenarlık eklemek istediğimiz kaynak görüntü.

- top: Üst tarafa eklenecek kenarlığın genişliği (piksel olarak).

- bottom: Alt tarafa eklenecek kenarlığın genişliği.

- left: Sol tarafa eklenecek kenarlığın genişliği.

- right: Sağ tarafa eklenecek kenarlığın genişliği.

- borderType: Eklenecek kenarlığın türünü belirler
(örn: cv2.BORDER_CONSTANT, cv2.BORDER_REFLECT).

- value: Kenarlığın rengi (sadece cv2.BORDER_CONSTANT için kullanılır).

Dönüş değeri:

Bir görüntü döndürür.

**borderType** parametresi, görüntüye eklenen kenarlığın stilini kontrol eder.
Genel seçenekler aşağıdaki gibidir:

1. cv2.BORDER_CONSTANT

Sabit bir renkli kenarlık ekler.
Renk, value parametresi ile belirlenir.
Örneğin: **value=(0, 0, 255)** kırmızı kenarlık için.

2. cv2.BORDER_REFLECT

Kenarlık, görüntünün kenar piksellerinin ayna yansıması şeklinde oluşturulur.  
Örneğin görüntü "abcdef" ise, kenarlık şöyle olur:

```
gfedcba | abcdef | gfedcba
```

3. cv2.BORDER_REFLECT_101

(veya **cv2.BORDER_DEFAULT**)
**BORDER_REFLECT** ile benzerdir fakat küçük bir fark vardır.  
Örneğin görüntü "abcdefgh" ise sonuç şöyle olur:

```
gfedcb | abcdefgh | gfedcba
````

4. cv2.BORDER_REPLICATE

Kenarlık, görüntünün en dıştaki pikseli tekrar edilerek oluşturulur.

Örneğin "abcdefgh" için:

```
aaaaa | abcdefgh | hhhhh
```

Örnek 1: Farklı Kenarlık Türleri Kullanımı

``` python
import cv2
from google.colab.patches import cv2_imshow

image = cv2.imread("/content/geeks14.png")

bordered_image_reflect = cv2.copyMakeBorder(image, 50, 50, 50, 50, cv2.BORDER_REFLECT)
bordered_image_reflect_101 = cv2.copyMakeBorder(image, 50, 50, 50, 50, cv2.BORDER_REFLECT_101)
bordered_image_replicate = cv2.copyMakeBorder(image, 50, 50, 50, 50, cv2.BORDER_REPLICATE)

print("Border with Reflect")
cv2_imshow(bordered_image_reflect)

print("Border with Reflect_101")
cv2_imshow(bordered_image_reflect_101)

print("Border with Replicate")
cv2_imshow(bordered_image_replicate)
```

çıktı: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250805171729058861/b2a.webp" width="200">
</p>

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250805171747172666/b2b.webp" width="200">
</p>

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250805171810536420/b2c.webp" width="200">
</p>


Örnek 2: fill_value ile Kenarlık Rengi Ayarlama

``` python
import cv2
from google.colab.patches import cv2_imshow

image = cv2.imread('/content/geeks14.png')
bordered_image = cv2.copyMakeBorder(image, 10, 10, 10, 10,
                                    cv2.BORDER_CONSTANT, value=(0, 0, 255))

print('Bordered Image with Red Border')
cv2_imshow(bordered_image)
```
çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250805172001505670/b3.webp" width="200">
</p>

**cv2.copyMakeBorder() Fonksiyonunun Kullanım Alanları**
1. Sinir Ağları için Görüntü Ön İşleme

Birçok makine öğrenimi modeli sabit boyutta giriş ister.
Bu nedenle copyMakeBorder() ile görüntüleri doldurarak boyutları eşitleyebiliriz.

2. Özellikleri Belirginleştirme

Bazen görüntüdeki nesnenin etrafına ek boşluk ekleyerek analizi kolaylaştırmak isteriz.

3. Görselleştirme

Birden fazla görüntüyü yan yana gösterirken kenarlık eklemek ayrımı netleştirir.

cv2.copyMakeBorder() Fonksiyonunun Sınırlamaları

- Sabit kenar boyutu:  
    Kenarlık boyutu elle verilir, dinamik değildir.

- Kısıtlı kenarlık türleri:  
    Desenli veya gradyan türünde özel kenarlık eklenemez.

- **BORDER_CONSTANT** renk sınırlamaları:  
    Kenarlık sadece tek renk olabilir, karmaşık desen olmaz.

- Otomatik yeniden boyutlandırma yok:  
    Sadece kenarlık ekler, görüntüyü belirli bir boyuta ölçeklemez.


### Basit Eşikleme 

Eşikleme, bilgisayarla görme ve görüntü işleme alanında nesneleri arka plandan ayırmak için kullanılan temel bir tekniktir. Bu yöntem, bir gri tonlu görüntüdeki her piksel değerini belirli bir eşik değeriyle karşılaştırarak çalışır. Bu karşılaştırmaya bağlı olarak piksellere genellikle 0 (siyah) veya 255 (beyaz) gibi yeni değerler atanır. OpenCV’de Python ile eşikleme yapmak için cv2.threshold fonksiyonu kullanılır.

Eşiklemede, konumu (x,y) olan ve yoğunluk değeri f(x,y) olan her bir piksel için:

- Eğer f(x,y) < T ise, piksel 0 (siyah) olarak ayarlanır.

- Eğer f(x,y) ≥ T ise, piksel maksimum değere (genelde 255, beyaz) ayarlanır.

Burada T eşik değeridir ve işlem genellikle görüntünün gri tonlu bir versiyonu üzerinde gerçekleştirilir.

| Teknik | Açıklama |
|--------|---------|
| `cv2.THRESH_BINARY` | Eşik değerin üzerindeki pikseller → **255**, altındaki → **0**. |
| `cv2.THRESH_BINARY_INV` | Binary’nin tersi: Eşik üzeri → **0**, eşik altı → **255**. |
| `cv2.THRESH_TRUNC` | Eşik üzerindeki pikseller → **eşik değerine ayarlanır**, altındakiler **değişmez**. |
| `cv2.THRESH_TOZERO` | Eşik altındaki pikseller → **0**, üzerindekiler **orijinal değerini korur**. |
| `cv2.THRESH_TOZERO_INV` | TOZERO’nun tersi: Eşik üstü → **0**, eşik altı **değişmeden kalır**. |


Adım 1: Kütüphaneleri İçe Aktarma ve Görüntü Hazırlığı:

``` python 

import cv2
import numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('input.png')
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
``` 
- cv2: görüntü okuma, işleme ve eşikleme uygulama işlemlerini yapar.

- numpy: hızlı görüntü veri işlemleri için verimli dizi işlemleri sağlar.

- matplotlib.pyplot: Colab gibi ortamlarda görüntüleri ve sonuçları göstermek için kullanılır.


Adım 2: Yardımcı Fonksiyon 

``` python
def show_image(img, title):
    plt.imshow(img, cmap='gray')
    plt.title(title)
    plt.axis('off')
    plt.show()
``` 

Adım 3: Orijinal Görüntüyü Gösterme:
``` python
show_image(gray_image, 'Original Grayscale Image')
``` 
çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250808164824311214/original-greyscale.webp" width="200">
</p>

Adım 4: Binary (İkili) Eşikleme: 

``` python
_, thresh_binary = cv2.threshold(gray_image, 120, 255, cv2.THRESH_BINARY)
show_image(thresh_binary, 'Binary Threshold ')
```
çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250808164847347129/binary-threshold.webp" width="200">
</p>



Adım 5: Binary Ters (Inverse) Eşikleme:

``` python 
_, thresh_binary_inv = cv2.threshold(
    gray_image, 120, 255, cv2.THRESH_BINARY_INV)
show_image(thresh_binary_inv, 'Binary Threshold Inverted ')
```

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250808164905556979/binary-inverted.webp" width="200">
</p>


Adım 6: Truncated (Kırpılmış) Eşikleme:
``` python 

_, thresh_trunc = cv2.threshold(gray_image, 120, 255, cv2.THRESH_TRUNC)
show_image(thresh_trunc, 'Truncated Threshold')
``` 

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250808164931121167/truncated-inverted.webp" width="200">
</p>

Adım 7: To Zero (Sıfıra Setleme) Eşikleme:

``` python 
_, thresh_tozero = cv2.threshold(gray_image, 120, 255, cv2.THRESH_TOZERO)
show_image(thresh_tozero, 'Set to 0 ')
```

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250808164946331355/set-to-0.webp" width="200">
</p>


Adım 8: To Zero Inverted (Sıfıra Setleme — Ters) Eşikleme:

``` python 
_, thresh_tozero_inv = cv2.threshold(
    gray_image, 120, 255, cv2.THRESH_TOZERO_INV)
show_image(thresh_tozero_inv, 'Set to 0 Inverted')
``` 

çıktı:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250808165004788095/0-to-inverted.webp" width="200">
</p>

### Renk Segmentasyonu

Color filtering (ya da renk segmentasyonu), görüntüdeki belirli nesneleri veya bölgeleri renklerine göre izole etmek için kullanılan temel bir görüntü işleme tekniğidir. Tüm resmi analiz etmek yerine, sadece belirli renk aralıklarına giren bölgelerle ilgilenmenizi sağlar.

Bu teknik aşağıdaki bilgisayarlı görü uygulamalarında önemli rol oynar:

- Nesne tespiti
- Nesne takibi
- Sahne analizi
- Otomasyonda görsel denetimler

Gereksiz renkleri filtreleyerek sistemler gerçek zamanlı olarak daha doğru tepkiler verebilir.

---

**Neden RGB Değil de HSV?**

RGB renk uzayında renkler parlaklık ve gölge farkından dolayı karışır; bu nedenle thresholding zorlu olabilir.

HSV renk uzayı ise:

- **Hue (Ton):** Renk türü (kırmızı, mavi, sarı vs.)
- **Saturation (Doygunluk):** Rengin yoğunluğu
- **Value (Parlaklık):** Rengin ne kadar aydınlık olduğu

Bu ayrım, renk aralıklarının tanımlanmasını kolaylaştırır.

---


| Fonksiyon | Açıklama |
|----------|----------|
| `cv2.cvtColor(src, code)` | Renk uzayı dönüşümü (BGR → HSV gibi) |
| `cv2.inRange(hsv, lower, upper)` | Belirtilen HSV aralığında ikili maske oluşturur |
| `cv2.bitwise_and(src1, src2, mask)` | Maskeyi uygulayarak istenen rengi izole eder |
| `cv2.VideoCapture(index)` | Webcam açar (0: varsayılan kamera) |
| `cv2.imshow(window, image)` | Görüntüyü ekrana verir |
| `cv2.waitKey(delay)` | Klavye girişi bekler |
| `cv2.destroyAllWindows()` | Tüm OpenCV pencerelerini kapatır |

---

**Kod Örneği: Gerçek Zamanlı Mavi Renk Tespiti**

Aşağıdaki Python kodu webcam görüntüsünden mavi renkleri gerçek zamanlı olarak algılar.  
Üç pencere açılır:

1. **Original Frame** – orijinal kamera görüntüsü  
2. **Blue Mask** – sadece mavi piksellerin beyaz göründüğü ikili maske  
3. **Blue Filtered Result** – mavi bölgelerin izole edilmiş hâli  

```python
import cv2
import numpy as np

cap = cv2.VideoCapture(0)

while True:
    _, frame = cap.read()
    
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    lower_blue = np.array([60, 35, 140])
    upper_blue = np.array([180, 255, 255])

    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    
    result = cv2.bitwise_and(frame, frame, mask=mask)


    cv2.imshow('Original Frame', frame)
    cv2.imshow('Blue Mask', mask)
    cv2.imshow('Blue Filtered Result', result)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
print("Exiting...") 
```
Orijinal Frame:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190623003704/Screenshot-3091-300x238.png" width="200">
</p>

Mavi Mask:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190623003738/Screenshot-3111-300x237.png" width="200">
</p>

Mavi Filtreli Sonuç: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190623003814/Screenshot-3121-300x235.png" width="200">
</p> 

Açıklama

- cv2.VideoCapture(0) → Webcam’i başlatır.

- cap.read() → Her kareyi okur.

- cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) → Görüntüyü HSV uzayına çevirir.

- lower_blue ve upper_blue → Mavi rengin HSV aralığı.

- cv2.inRange() → Bu aralıkta kalan pikseller için ikili maske oluşturur.

- cv2.bitwise_and() → Maskeyi uygulayarak sadece mavi bölgeleri gösterir.

- cv2.imshow() → Görüntüleri ekrana verir.

- cv2.waitKey(1) → “q” basıldığında döngü sonlanır. 


### Görüntü Rötuşu(Image inpainting)


Image inpainting, görüntülerdeki gürültü, çizik, yazı gibi bozulmaları kaldırma işlemidir.  
Özellikle **eski fotoğrafların restorasyonunda** oldukça kullanışlıdır. Fotoğraflardaki çizikler veya mürekkep lekeleri bu yöntemle dijital olarak temizlenir.

Inpainting, hasarlı pikselleri komşu piksel bilgileriyle doldurarak bölgenin arka planla kaynaşmasını sağlar.


---

**OpenCV ile Maskeyi Manuel Oluşturma**

1. Hasarlı görüntüyü okumak  
2. Görüntünün yüksekliğini ve genişliğini almak  
3. Siyah pikselleri beyaza, diğer tüm pikselleri siyaha dönüştürmek  
4. Maskeyi `.jpg` gibi bir formatta kaydetmek  

---

**Python Kod Örneği – Maske Oluşturma**

```python
import cv2
import numpy as np

damaged_img = cv2.imread(filename=r"cat_damaged.png")

height, width = damaged_img.shape[0], damaged_img.shape[1]

for i in range(height):
    for j in range(width):
        if damaged_img[i, j].sum() > 0:
            damaged_img[i, j] = 0
        else:
            damaged_img[i, j] = [255, 255, 255]

mask = damaged_img
cv2.imwrite('mask.jpg', mask)

cv2.imshow("damaged image mask", mask)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

OpenCV iki farklı inpainting algoritması sunar:


1. Fast Marching Method (FMM) – **cv2.INPAINT_TELEA**


Temel Mantık:

- Algoritma, maskenin sınırındaki piksellerden başlayarak içeri doğru ilerler.

- Her piksel, arka plan komşu piksellerinin ağırlıklı ortalamasıyla doldurulur.

- Yakındaki piksellere ve sınırdaki piksellere daha fazla ağırlık verilir.


2. Navier-Stokes Method – **cv2.INPAINT_NS**


Temel Mantık:

- Kısmi diferansiyel denklemlerden ilham alır.

- Kenarlardan içeri doğru bilgi taşır.

- Aynı yoğunluktaki noktaları birleştiren isofot çizgileri korunur.

- Sonunda renk varyasyonu azaltılarak bölge düzgün bir şekilde doldurulur.

OpenCV ile Inpainting Örneği:

Aşağıdaki kod, oluşturduğunuz maskeyi kullanarak görüntüyü Navier-Stokes (INPAINT_NS) yöntemiyle rötuşlar. 

``` python 
import numpy as np
import cv2

img = cv2.imread('cat_damaged.png')

mask = cv2.imread('cat_mask.png', 0)

dst = cv2.inpaint(img, mask, 3, cv2.INPAINT_NS)

cv2.imwrite('cat_inpainted.png', dst)
```

### Background Subtraction (Arka Plan Çıkarma)

Bir güvenlik kamerası kaydı izlediğinizi ve **sadece hareket eden insanları veya araçları** takip etmek istediğinizi düşünün.  
Duvarlar, binalar, park edilmiş arabalar veya sabit nesneler dikkatinizi dağıtır.  
İşte **Background Subtraction** (arka plan çıkarma) tam bu noktada devreye girer.

Background Subtraction, bir video dizisinde **hareketli nesneleri (foreground)** sabit sahneden **ayırmak** için kullanılan bir bilgisayar görüsü tekniğidir. Sonuç genellikle hareket eden bölgelerin beyaz, arka planın siyah olduğu **binary mask** görüntüsüdür.


---

**Yaygın Background Subtraction Algoritmaları**

**1. BackgroundSubtractorMOG**
- Gaussian Mixture Model’e (GMM) dayanır  
- Temel seviyede arka plan çıkarma yapar

**2. BackgroundSubtractorMOG2**
- MOG’un gelişmiş versiyonudur  
- Değişen ışık koşullarına daha iyi uyum sağlar  
- **Gölge tespiti** daha başarılıdır

**3. Geometric Multigrid**
- İstatistiksel analiz ve piksel başına Bayesian segmentasyon kullanır  
- Daha gelişmiş, daha stabil sonuçlar verebilir

---

**Örnek: OpenCV ile Background Subtraction (MOG2)**

Aşağıdaki örnek, OpenCV'nin MOG2 algoritmasını kullanarak bir videodaki hareketli nesneleri ayırır.  
Program:

``` python 

import numpy as np
import cv2

cap = cv2.VideoCapture('/home/sourabh/Downloads/people-walking.mp4')

fgbg = cv2.createBackgroundSubtractorMOG2()

while True:
    ret, frame = cap.read()
    if not ret:
        break

    fgmask = fgbg.apply(frame)

    cv2.imshow('Original Frame', frame)
    cv2.imshow('Foreground Mask', fgmask)

    if cv2.waitKey(30) & 0xFF == 27:
        break

cap.release()
cv2.destroyAllWindows()
``` 

Orijinal Frame:

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190628230551/Screenshot-from-2019-06-28-21-52-12-300x190.jpg" width="400">
</p>

Ön plan maskesi: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190628230638/Screenshot-from-2019-06-28-21-52-121-300x193.jpg" width="400">
</p> 

**Açıklama**

- **cv2.VideoCapture()**  
  Video dosyasını veya kamerayı açar ve kareleri okumaya hazır hâle getirir.

- **cv2.createBackgroundSubtractorMOG2()**  
  Arka plan çıkarma için MOG2 modelini oluşturur.  
  Bu model, hareketli nesneleri arka plandan ayırmak için gelişmiş Gaussian karışım modelleri kullanır.

- **fgbg.apply(frame)**  
  Her kareye arka plan çıkarma uygular ve **binary bir maske** döndürür.  
  - Beyaz (255): Hareket tespit edilen bölgeler (foreground)  
  - Siyah (0): Arka plan

- **cv2.imshow()**  
  Hem orijinal videoyu hem de foreground mask görüntüsünü gerçek zamanlı olarak ekranda gösterir.

### Video Oynatma 

- cv2.VideoCapture(0) → Varsayılan web kamerayı açar

- cv2.VideoCapture(1) → İkinci web kamerayı açar

- cv2.VideoCapture("file.mp4") → Bir video dosyasını yükler

Video başarılı şekilde yüklendi mi kontrol etme:

``` python 
if not cap.isOpened():
    print("Error: Could not open video file.")
    exit()
    
```

Videoyu kare kare okuyup gösterme: 

``` python 
while True:
    ret, frame = cap.read()

    if not ret:
        break  

    cv2.imshow("Video", frame)

    if cv2.waitKey(25) & 0xFF == ord('q'):
        break
```

Kamerayı serbest bırakma ve pencereleri kapatın yoksa diğer uygulamalarda sıkıntı çıkabilir.

``` python 
cap.release()
cv2.destroyAllWindows()
``` 

Komple Kod:

``` python 
import cv2

cap = cv2.VideoCapture("video.mp4")

if not cap.isOpened():
    print("Error: Could not open video file.")
    exit()

while True:
    ret, frame = cap.read()

    if not ret:
        break  

    cv2.imshow("Video", frame)

    if cv2.waitKey(25) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
``` 

### OpenCV’de olayları kullanarak video çıktısı üzerinde tıklamaya tepkisi alma 

Videoyu Kare Kare Okuma ve Mouse Callback Ayarlama: 

- **cap.read()** iki değer döner:

  - **ret**: Kare başarıyla okunduysa True

  - **frame**: Okunan kare

- **cv2.waitKey()**
→ Verilen süre boyunca (ms) pencereyi gösterir, 0 verilirse tuşa basılana kadar bekler 

``` python 
while(cap.isOpened()):
    ret, frame = cap.read()

    if ret == True:
        cv2.imshow("GFG", frame)
        cv2.setMouseCallback('GFG', mouse_click, param=frame)

        if cv2.waitKey(25) & 0xFF == ord('q'):
            break
    else:
        break
```

Mouse Tıklama Fonksiyonunu Tanımlama 

- Sol tık → görüntüyü kaydedelim

- Sağ tık → o anki frame’i başka bir pencerede gösterelim

``` python 

def mouse_click(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        print("left click")
        cv2.imwrite("frame.jpg", param)

    if event == cv2.EVENT_RBUTTONDOWN:
        print("right click")
        cv2.imshow("Current Frame", param)
``` 

Tüm Kod: 

``` python 

import cv2

def mouse_click(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:
        print("left click")
        cv2.imwrite("frame.jpg", param)

    if event == cv2.EVENT_RBUTTONDOWN:
        print("right click")
        cv2.imshow("Current Frame", param)

cap = cv2.VideoCapture("test.mp4")

if cap.isOpened() == False:
    print("Error in opening file.")
else:
    while(cap.isOpened()):
        ret, frame = cap.read()

        if ret == True:
            cv2.imshow("GFG", frame)
            cv2.setMouseCallback('GFG', mouse_click, param=frame)

            if cv2.waitKey(25) & 0xFF == ord('q'):
                break
        else:
            break

cap.release()
cv2.destroyAllWindows()
``` 

### OpenCV' de zamanı gösterne

Video kareleri üzerinde mevcut tarih ve saati göstermek için:

1. **cv2.VideoCapture()** kullanarak videoyu yakalama

2. Bir döngü içinde video karelerini okuma.

3. **datetime.datetime.now()** ile sistemin mevcut zamanını alma.

4. **cv2.putText()** kullanarak zaman bilgisini her kareye yazdırma.

5. Video bitene veya kullanıcı çıkış yapana kadar güncellenmiş kareleri ekranda gösterme.

Örnek Kod:

``` python 

import cv2
import datetime

vid = cv2.VideoCapture('sample.mp4')
while vid.isOpened():
    ret, frame = vid.read()
    if not ret:
        break

    font = cv2.FONT_HERSHEY_SCRIPT_COMPLEX
    dt = str(datetime.datetime.now())
    frame = cv2.putText(frame, dt,
                        (10, 100),           
                        font, 1,             
                        (210, 155, 155),    
                        2,                   
                        cv2.LINE_8)         

    cv2.imshow('Video with Date & Time', frame)

    key = cv2.waitKey(1)
    if key == ord('q') or key == 27: 
        break

vid.release()
cv2.destroyAllWindows()
``` 

çıktı: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20200323230618/vid3.png" alt="Video frame" width = 400 height = 300>
</p>

Açıklama:

- **cv2.VideoCapture('sample.mp4')** video dosyasını açar ve bir “capture” (yakalama) nesnesi oluşturur.

- **vid.read()** videoyu kare kare (frame frame) okur;

  - **ret** okumanın başarılı olup olmadığını gösteren Boolean değerdir,

  - **frame** ise okunan görüntü karesidir.

- **datetime.datetime.now()** sistemin o anki tarih ve saat bilgisini alır.

- **cv2.putText(frame, dt, ...)** her video karesinin üzerine tarih ve saat bilgisini metin olarak yazar (overlay yapar).

- **cv2.imshow('Video with Date & Time', frame)** zaman damgası eklenmiş videoyu ekranda gösterir.

- **cv2.waitKey(1)** bir tuşa basılmasını bekler; q veya ESC tuşuna basılırsa döngüden çıkar.

- Son olarak **vid.release()** video kaynağını serbest bırakır ve **cv2.destroyAllWindows()** tüm OpenCV pencerelerini kapatır.

### Video Süresini Alma

Bir videonun süresini almak için:

1. Modülleri İçe Aktar:
Video işleme için cv2, süre formatlama için datetime.timedelta kullanılır.

2. Videoyu Yükle:
**cv2.VideoCapture("path/to/video.mp4")** ile bir VideoCapture nesnesi oluşturulur.

3. Özellikleri Al:

Toplam kare sayısı → **CAP_PROP_FRAME_COUNT**

FPS (saniyedeki kare sayısı) → **CAP_PROP_FPS**
Bu değerler VideoCapture üzerinden okunur.

4 .Süreyi Hesapla:
Video süresi: toplam kare / FPS formülüyle hesaplanır.
Son olarak süre datetime.timedelta ile daha okunabilir hale dönüştürülür.

``` python 

import cv2
import datetime

video = cv2.VideoCapture('amerikan_futbolu.mp4')
frames = video.get(cv2.CAP_PROP_FRAME_COUNT)
fps = video.get(cv2.CAP_PROP_FPS)

seconds = round(frames / fps)
video_time = datetime.timedelta(seconds=seconds)

print(f"Frames: {frames}")
print(f"FPS: {fps}")
print(f"Duration in seconds: {seconds}")
print(f"Video time (HH:MM:SS): {video_time}")
``` 

çıktı:

``` 
Frames: 840.0
FPS: 30.0
Duration in seconds: 28
Video time (HH:MM:SS): 0:00:28
``` 
Açıklama:

- **cv2.VideoCapture('path')**, video dosyası için bir capture (yakalama) nesnesi oluşturur.

- **video.get(cv2.CAP_PROP_FRAME_COUNT)** toplam kare (frame) sayısını alır.

- **video.get(cv2.CAP_PROP_FPS)** videonun saniyedeki kare sayısını (FPS) getirir.

- **round(frames / fps)** toplam süreyi saniye cinsinden hesaplar.

- **datetime.timedelta(seconds=seconds)** bu saniye değerini SS:DD:SS (saat:dakika:saniye) formatına dönüştürür

### Video Birleştirme 

Önemli Noktalar:

- İki video aynı çözünürlükte (width, height) olmalı. 

- FPS’leri uyumlu olmalı yoksa kare senkronizasyonu bozulur. 

- Eğer foreground videonun arka planı sabit renk (örneğin siyah) ve subject'lar bu satırla çekildiyse, alfa mask oluşturmak (background siyah → saydam, subject → opak) daha kolay oluyor. 

1. Ana Döngü: 

``` python 
while True:
``` 


Bu döngü videolardan frame okundukça sürecek sonsuz bir döngüdür. 

Video işleme her zaman frame-by-frame yapılır.  
Bir videoyu izlemek = kareleri ardışık okumak demektir.  
Bu döngü oynatıcı mantığıyla çalışır:  

- Her seferinde frame oku

- İşle

- Göster

- Bir sonraki kareye geç

2. Frame Okuma — vid.read()

``` python 
ret_fg, frame_fg = fg.read()
ret_bg, frame_bg = bg.read()
```  

- **read()** fonksiyonu videodan 1 kare okur.

2 şey döner:

  - **ret** → Başarılıysa True, video bittiyse False

  - **frame** → Okunan görüntü

Video bittiğinde veya hata olunca ret=False olur → döngü kırılır

3. Gri Tonlama(mask için)

``` python 
gray = cv2.cvtColor(frame_fg, cv2.COLOR_BGR2GRAY)
``` 

Foreground videosunu gri seviyeye çevirir.

Alfa maskesi oluşturmak için sade tek kanallı görüntü gerekir.
Gri seviye = piksel parlaklığı (0–255). 

4. Alfa Maskesi Oluşturma

``` python 

alpha = gray.astype(float) / 255.0
alpha = cv2.merge([alpha, alpha, alpha])
```

- Gri görüntüyü float türüne çevirip 0–1 arasına normalize eder.

- Sonra 3 kanala kopyalayarak (R,G,B) için maske oluşturur.

Bu maskenin her pikseli şu anlama gelir:

- 1.0 → tamamen foreground

- 0.0 → tamamen background

- 0.3 → %30 foreground + %70 background
vb.

Blending’i sağlayan şey tam olarak bu maske.

5. Birleştirme 

``` python 
blended = cv2.multiply(alpha, fg_f) + cv2.multiply(1.0 - alpha, bg_f)
``` 

Örnek Kod: 

``` python 

import cv2
import numpy as np

bg_path = "background.mp4"
fg_path = "foreground.mp4"

bg = cv2.VideoCapture(bg_path)
fg = cv2.VideoCapture(fg_path)

while True:
    ret_fg, frame_fg = fg.read()
    ret_bg, frame_bg = bg.read()

    if not ret_fg or not ret_bg:
        break

    gray = cv2.cvtColor(frame_fg, cv2.COLOR_BGR2GRAY)

    alpha = gray.astype(float) / 255.0
    alpha = cv2.merge([alpha, alpha, alpha])  

    fg_f = frame_fg.astype(float)
    bg_f = frame_bg.astype(float)
    
    blended = cv2.multiply(alpha, fg_f) + cv2.multiply(1.0 - alpha, bg_f)
    blended = blended.astype(np.uint8)

    cv2.imshow("Blended Video", blended)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

bg.release()
fg.release()
cv2.destroyAllWindows()
``` 

### OpenCV kamera görme ve özellik değiştirme

``` python 
import cv2

# Kamera aç
cam = cv2.VideoCapture(0)

# Kameranın açılıp açılmadığını kontrol et
if not cam.isOpened():
    print("Kamera açılamadı!")
else:
    # Önemli bazı özellikleri oku ve yazdır
    width = cam.get(3)       # Frame genişliği
    height = cam.get(4)      # Frame yüksekliği
    fps = cam.get(5)         # FPS
    brightness = cam.get(10) # Parlaklık
    contrast = cam.get(11)   # Kontrast
    saturation = cam.get(12) # Doygunluk

# ya da 

    width = cam.get(cv2.CAP_PROP_FRAME_WIDTH)
    height = cam.get(cv2.CAP_PROP_FRAME_HEIGHT)
    fps = cam.get(cv2.CAP_PROP_FPS)
    brightness = cam.get(cv2.CAP_PROP_BRIGHTNESS) # Parlaklık
    contrast = cam.get(cv2.CAP_PROP_CONTRAST)   # Kontrast
    saturation = cam.get(cv2.CAP_PROP_SATURATION) # Doygunluk


    print(f"Genişlik: {width}")
    print(f"Yükseklik: {height}")
    print(f"FPS: {fps}")
    print(f"Parlaklık: {brightness}")
    print(f"Kontrast: {contrast}")
    print(f"Doygunluk: {saturation}")

# Kamera kapat
cam.release()

# çıktı 

Genişlik: 640.0
Yükseklik: 480.0
FPS: 30.0
Parlaklık: 0.0
Kontrast: 32.0
Doygunluk: 64.0
``` 
**cam.set()** nedir? 

- `cam` → `cv2.VideoCapture` objesi
- `set()` → kameranın **özelliklerini değiştirmek** için kullanılır
- Yani bir nevi kamera ayarlarını program üzerinden yapmak gibi düşünebilirsin. 

Kullanımı:

``` python 
cam.set(prop_id, value)
``` 

- `prop_id` → değiştirmek istediğin özellik (sabit sayı veya OpenCV sabiti)
- `value` → yeni değer 

Örnekler: 

| Kod | Ne yapıyor |
| --- | --- |
| `cam.set(3, 640)` | Kare genişliğini 640 piksel yap |
| `cam.set(4, 480)` | Kare yüksekliğini 480 piksel yap |
| `cam.set(10, 0.5)` | Parlaklığı %50 yap |
| `cam.set(11, 0.7)` | Kontrastı %70 yap | 

**Önemli noktalar**
1. `cam.set()` her zaman **başarılı olmayabilir**
    - Bazı kameralar belirli çözünürlükleri desteklemez
    - Windows, Linux veya Mac’te farklı davranabilir
2. `cam.get(prop_id)` ile değiştirdiğin değeri **kontrol edebilirsin**:

```python
cam.set(3, 320)
print(cam.get(3))  # gerçekten 320 oldu mu bak
```

---

- `cam.set()` → Kamera özelliklerini **ayarlamak** için
- `cam.get()` → Kamera özelliklerini **okumak** için

---

### `cam.get()` ve `cam.set()` ilişkisi

- Hem `get()` hem de `set()` **aynı `prop_id` değerlerini** kullanır.
- Yani bir özelliği okumak için `get()` → değiştirmek için `set()`

Örnek:

| Özellik | `prop_id` | `get()` kullanımı | `set()` kullanımı |
| --- | --- | --- | --- |
| Genişlik | 3 | `cam.get(3)` | `cam.set(3, 320)` |
| Yükseklik | 4 | `cam.get(4)` | `cam.set(4, 240)` |
| FPS | 5 | `cam.get(5)` | `cam.set(5, 15)` |
| Parlaklık | 10 | `cam.get(10)` | `cam.set(10, 0.5)` |
| Kontrast | 11 | `cam.get(11)` | `cam.set(11, 0.7)` |

---

**Mantık**

1. `cam.get(prop_id)` → Kamera özellik değerini oku
2. `cam.set(prop_id, value)` → Kameraya yeni değer ver

> Prop ID’ler aynı olduğu sürece get() ile okuduğun özellik, set() ile değiştirilebilir.
> 

---

**Örnek akış**

```python
import cv2

cam = cv2.VideoCapture(0)

# Mevcut çözünürlüğü oku
print(cam.get(3), cam.get(4))  # width, height

# Çözünürlüğü değiştir
cam.set(3, 320)
cam.set(4, 240)

# Değişti mi kontrol et
print(cam.get(3), cam.get(4))

```

- Çıktı önce orijinal çözünürlüğü, sonra ayarladığın yeni çözünürlüğü gösterir.

örnek kod: 

``` python
import cv2

cam = cv2.VideoCapture(0)

print(cam.get(3))
print(cam.get(4))

cam.set(3, 320)
cam.set(4, 240)

if not cam.isOpened():
    print("kamera tanınmadı")
    exit()

while True:
    ret, frame = cam.read()

    frame = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)

    if not ret:
        print("kameradan görüntü okunamıyor")
        break

    cv2.imshow("kamera",frame) 

    if cv2.waitKey(1) & 0xFF == ord("q"):
        print("görüntü sonlandırıldı")
        break

cam.release()
cv2.destroyAllWindows()

```

### OpenCV’nin temel **çizim fonksiyonları** şunlardır:

1. **`cv2.line()`** → Çizgi çizer
    
    ```python
    cv2.line(img, (x1,y1), (x2,y2), color, thickness)
    ```
    
2. **`cv2.rectangle()`** → Dikdörtgen çizer (dolu veya sadece kenarlı)
    
    ```python
    cv2.rectangle(img, (x1,y1), (x2,y2), color, thickness)
    ```
    
3. **`cv2.circle()`** → Daire çizer
    
    ```python
    cv2.circle(img, (x,y), radius, color, thickness)
    ```
    
4. **`cv2.ellipse()`** → Elips çizer
    
    ```python
    cv2.ellipse(img, (x,y), (axis1,axis2), angle, startAngle, endAngle, color, thickness)
    ```
    
5. **`cv2.polylines()`** → Çokgen çizer (birden fazla noktayı birleştirir)
    
    ```python
    cv2.polylines(img, [pts], isClosed, color, thickness)
    ```
    
6. **`cv2.fillPoly()`** → Çokgeni doldurur
    
    ```python
    cv2.fillPoly(img, [pts], color)
    ```
    
7. **`cv2.putText()`** → Resme yazı ekler (teknik olarak çizim)
    
    ```python
    cv2.putText(img, "Merhaba", (x,y), font, scale, color, thickness)
    ```
    

```python
import cv2
import numpy as np

# Boş bir siyah resim oluşturuyoruz
img = np.zeros((600, 800, 3), dtype=np.uint8)

# 1. Çizgi (line)
cv2.line(img, (50, 50), (250, 50), (255, 0, 0), 5)  # mavi kalın çizgi

# 2. Dikdörtgen (rectangle)
cv2.rectangle(img, (50, 100), (250, 200), (0, 255, 0), 3)  # yeşil kenarlı dikdörtgen
cv2.rectangle(img, (300, 100), (500, 200), (0, 255, 0), -1) # yeşil dolu dikdörtgen

# 3. Daire (circle)
cv2.circle(img, (150, 300), 50, (0, 0, 255), 5)   # kırmızı kenarlı daire
cv2.circle(img, (350, 300), 50, (0, 0, 255), -1)  # kırmızı dolu daire

# 4. Elips (ellipse)
cv2.ellipse(img, (150, 450), (100, 50), 0, 0, 360, (255, 255, 0), 3) # sarı elips kenarlı
cv2.ellipse(img, (400, 450), (100, 50), 45, 0, 360, (255, 255, 0), -1) # sarı dolu elips

# 5. Çokgen (polylines ve fillPoly)
pts = np.array([[550, 50], [650, 50], [700, 150], [600, 200]], np.int32)
pts = pts.reshape((-1, 1, 2))
cv2.polylines(img, [pts], isClosed=True, color=(255, 0, 255), thickness=3)  # kenarlı çokgen
pts2 = np.array([[550, 250], [650, 250], [700, 350], [600, 400]], np.int32)
pts2 = pts2.reshape((-1, 1, 2))
cv2.fillPoly(img, [pts2], (255, 0, 255))  # dolu çokgen

# 6. Yazı (putText)
cv2.putText(img, "OpenCV Ornek", (50, 550), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

# Resmi göster
cv2.imshow("OpenCV Cizimler", img)
cv2.waitKey(0)
cv2.destroyAllWindows()

```

Açıklamalar:

- Renkler **BGR formatında** (mavi, yeşil, kırmızı, vs).
- `1` parametresi **dolu şekil** anlamına gelir.
- `polylines` kenarlı çokgen, `fillPoly` dolu çokgen için kullanılır.
- `putText` ile resme yazı ekleyebilirsin.

### bu pts ne
`pts` **points** yani çizilecek çokgenin köşe koordinatlarını tutan bir `numpy` dizisidir. OpenCV’de çokgen çizmek için **tüm köşe noktalarını bir dizi içinde vermen gerekiyor**.

Örneğin:

```python
pts = np.array([[550, 50], [650, 50], [700, 150], [600, 200]], np.int32)

```

- Bu dört adet `(x, y)` koordinatı var.
- Yani çokgenin köşeleri: `(550,50)`, `(650,50)`, `(700,150)`, `(600,200)`.

Ama OpenCV’nin `polylines` ve `fillPoly` fonksiyonları **nokta dizisinin belirli bir formatta olmasını** ister:

```python
pts = pts.reshape((-1, 1, 2))

```

- `-1` → otomatik olarak kaç nokta varsa o kadar satır.
- `1` → her nokta bir "satır" olarak tutulur (OpenCV’nin formatı).
- `2` → her nokta `(x, y)` iki değere sahip.

Sonra bunu kullanırsın:

```python
cv2.polylines(img, [pts], isClosed=True, color=(255,0,255), thickness=3)
cv2.fillPoly(img, [pts], color=(255,0,255))

```

- `[pts]` → liste içine almak gerekiyor, çünkü OpenCV birden fazla çokgeni aynı anda çizebilir.
- `isClosed=True` → ilk ve son noktayı birleştirir, çokgen kapalı olur.

Özetle:

**`pts` = çokgenin köşe noktaları**, ve OpenCV’nin istediği şekilde **3 boyutlu diziye reshape** ediyoruz. 


### `cv2.setMouseCallback` nasıl çalışıyor?

Şu satır:

```python
cv2.setMouseCallback("paint", draw)

```

OpenCV'ye diyor ki:

> “paint adlı pencereye biri fare ile tıklarsa,
> 
> 
> ben `draw` fonksiyonunu çağıracağım.”
> 

Ve **çağırırken şu 5 parametreyi otomatik gönderiyor**:

```python
draw(event, x, y, flags, param)

```

Yani:

- **event** → fare olayı
    
    (sol tık, sağ tık, hareket, bırakma vs.)
    
- **x** → farenin **o anki X pozisyonu**
- **y** → farenin **o anki Y pozisyonu**
- **flags** → tuşlar basılı mı, ctrl/shift basılı mı?
- **param** → ekstra veri (genelde kullanılmaz)

Sen çağırmıyorsun, **OpenCV çağırıyor**.

---

**Diyelim fareyi 100, 200 noktasında sola tıklıyorsun.**

OpenCV otomatik olarak şunu yapar:

```python
draw(cv2.EVENT_LBUTTONDOWN, 100, 200, flags, param)

```

Sen sadece:

```python
def draw(event, x, y, flags, param):
    print(x, y)

```

diye yazınca

**x = 100, y = 200** yazdırır.

---

**Python fonksiyonunda tüm parametreleri kullanmaya gerek yok.**

OpenCV sana **5 parametre gönderir**, ama sen istersen sadece **2 tanesini** alabilirsin.

Python buna izin veriyor.

---

**Nasıl çalışıyor?**

`setMouseCallback` senin fonksiyonunu şöyle çağırıyor:

```python
draw(event, x, y, flags, param)

```

Yani şu:

```python
def draw(event, x, y, flags, param):
    print(x, y)

```

Bu hâlâ 5 parametreli fonksiyon.

Sadece **3 tanesini kullanmıyorsun**, Python buna:

> “Tamam aga, bunlar var ama gerekmiyormuş, sıkıntı yok.”
> 

diyor.

---

**parametrelerden bazılarını silsem ne olur?**

Örneğin:

```python
def draw(x, y):
    print(x, y)

```

O zaman **HATA verir** çünkü OpenCV **5 parametre göndermeye çalışıyor**, ama fonksiyon sadece **2 tane bekliyor**.

---

**Ama şu olur:**

İstemediğin parametreleri `_` ile gizlenebilir: 

```python
def draw(event, x, y, _, __):
    print(x, y)

```

Bu Python’da:

- “Bu parametreleri alıyorum ama kullanmıyorum” anlamına gelir
- En temiz yöntemdir. 

örnek kod: 

``` python 
import cv2 
import numpy as np


def draw(event, x, y, flags, param):
    print(x,y)
    pass

img = np.ones((512,512,3),np.uint8)

cv2.namedWindow("paint")

cv2.setMouseCallback("paint",draw)

while True:
    cv2.imshow("paint",img)
    if cv2.waitKey(1) & 0xFF == ord("q"):
        break

cv2.destroyAllWindows()
``` 

### Cascade Kullanarak Yüz Tespiti Uygulaması

1. Gerekli Kütüphanelerin İçeri Aktarılması 

``` python 
import cv2
import numpy as np
import matplotlib.pyplot as plt
``` 
2. Haar Cascade  Yükleme 

``` python 

face_cascade = cv2.CascadeClassifier("/content/haarcascade_frontalface_default.xml")
eye_cascade = cv2.CascadeClassifier('/content/haarcascade_eye.xml')
``` 
3. Yüz Tespiti Fonksiyonunun Oluşturulması

``` python 
def adjusted_detect_face(img):
    face_img = img.copy()
    face_rect = face_cascade.detectMultiScale(face_img, scaleFactor=1.2, minNeighbors=5)

    for (x, y, w, h) in face_rect:
        cv2.rectangle(face_img, (x, y), (x + w, y + h), (255, 255, 255), 10)
        
    return face_img
``` 

4. Göz Tespiti Fonksiyonunun Oluşturulması 

``` python 

def detect_eyes(img):
    eye_img = img.copy()
    eye_rect = eye_cascade.detectMultiScale(eye_img, scaleFactor=1.2, minNeighbors=5)

    for (x, y, w, h) in eye_rect:
        cv2.rectangle(eye_img, (x, y), (x + w, y + h), (255, 255, 255), 10)
        
    return eye_img
``` 

5. Görselin Yüklenmesi 

``` python 

img = cv2.imread('/content/andrew.jpg')
img_copy1 = img.copy()
img_copy2 = img.copy()
img_copy3 = img.copy()

plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
``` 

çıktı: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250415122620158295/Sample-image.webp" alt="Sample image" width = 200>
</p> 

Yüz ve göz tespiti için gerekli kodu çalıştırdığında ekranda yüz tespit edilmiş görüntüyü görürsün ve aynı zamanda bu görüntü face.jpg adıyla kaydedilir. Aşağıdaki kod sadece yüz tespitini yapar, ekranda gösterir ve dosyaya yazar: 

``` python 

face = adjusted_detect_face(img_copy1)
plt.imshow(cv2.cvtColor(face, cv2.COLOR_BGR2RGB))
plt.show()

cv2.imwrite('face.jpg', face)
``` 

çıktı : 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250415122633764097/face.webp" alt="Sample image" width = 200>
</p>  

Göz tespiti: 

``` python 

eyes = detect_eyes(img_copy2)
plt.imshow(cv2.cvtColor(eyes, cv2.COLOR_BGR2RGB))
plt.show()
cv2.imwrite('eyes.jpg', eyes) 
``` 
çıktı: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250415122655286196/eyes.webp" alt="Sample image" width = 200>
</p> 

### OpenCV fare olayları 


tüm mouse hareketlerini görmek için kod: 
``` python 
import cv2
[print(i) for i in dir(cv2) if 'EVENT' in i]
``` 

Mouse Tuşu / Klavye Modifier Bayrakları

(Bunlar “hangi tuş basılı?” bilgisini verir.)

EVENT_FLAG_ALTKEY → ALT tuşu basılı.

EVENT_FLAG_CTRLKEY → CTRL tuşu basılı.

EVENT_FLAG_SHIFTKEY → SHIFT tuşu basılı.

EVENT_FLAG_LBUTTON → Sol mouse tuşu basılı.

EVENT_FLAG_MBUTTON → Orta mouse tuşu basılı.

EVENT_FLAG_RBUTTON → Sağ mouse tuşu basılı.

Sol Tık Olayları

EVENT_LBUTTONDOWN → Sol tuş basıldı.

EVENT_LBUTTONUP → Sol tuş bırakıldı.

EVENT_LBUTTONDBLCLK → Sol tuşa çift tık.

Orta Tık Olayları

EVENT_MBUTTONDOWN → Orta tuş basıldı.

EVENT_MBUTTONUP → Orta tuş bırakıldı.

EVENT_MBUTTONDBLCLK → Orta tuşa çift tık.

Sağ Tık Olayları

EVENT_RBUTTONDOWN → Sağ tuş basıldı.

EVENT_RBUTTONUP → Sağ tuş bırakıldı.

EVENT_RBUTTONDBLCLK → Sağ tuşa çift tık.

Scroll & Mouse Hareket

EVENT_MOUSEMOVE → Fare hareket ediyor.

EVENT_MOUSEWHEEL → Fare tekerleği dikey kaydırma.

EVENT_MOUSEHWHEEL → Fare tekerleği yatay kaydırma. 

uygulama : 

``` python 

import cv2
 
def click_event(event, x, y, flags, params):
    if event == cv2.EVENT_LBUTTONDOWN:
        print(x, y)
        font = cv2.FONT_HERSHEY_SIMPLEX
        cv2.putText(img, f"{x},{y}", (x, y), font, 1, (255, 0, 0), 2)
        cv2.imshow('image', img)

    if event == cv2.EVENT_RBUTTONDOWN:
        print(x, y)
        font = cv2.FONT_HERSHEY_SIMPLEX
        b, g, r = img[y, x]
        cv2.putText(img, f"{b},{g},{r}", (x, y), font, 1, (255, 255, 0), 2)
        cv2.imshow('image', img)

if __name__=="__main__":
    img = cv2.imread('lena.jpg', 1)
    cv2.imshow('image', img)
    cv2.setMouseCallback('image', click_event)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
``` 


<video width="640" controls>
  <source src="https://media.geeksforgeeks.org/wp-content/uploads/20200714083457/cv2-clicking.mp4" type="video/mp4">
  Tarayıcınız video etiketini desteklemiyor.
</video> 


### OpenCV renk Trackbarları 

- 512 x 512 boyutunda, 3 kanallı (BGR renkli) siyah bir pencere oluştur.

- cv2.createTrackbar() kullanarak Blue (Mavi), Green (Yeşil) ve Red (Kırmızı) adında üç tane trackbar ekle.

- Her trackbar’ın değeri 0–255 aralığında olsun.

- Sürekli bir döngü içinde:

  - cv2.getTrackbarPos() ile trackbarların o anki değerlerini al.

  - Aldığın bu B, G, R değerlerine göre pencerenin arka plan rengini değiştir.

- Kullanıcı ESC tuşuna basınca programdan çık.

``` python 
import cv2
import numpy as np

def emptyFunction():
    pass

def main():
    image = np.zeros((512, 512, 3), np.uint8) 
    windowName = "OpenCV Color Palette"
    cv2.namedWindow(windowName) 
    cv2.createTrackbar('Blue', windowName, 0, 255, emptyFunction)
    cv2.createTrackbar('Green', windowName, 0, 255, emptyFunction)
    cv2.createTrackbar('Red', windowName, 0, 255, emptyFunction)
    
    while True:
        cv2.imshow(windowName, image)
        if cv2.waitKey(1) == 27:
            break
        blue = cv2.getTrackbarPos('Blue', windowName)
        green = cv2.getTrackbarPos('Green', windowName)
        red = cv2.getTrackbarPos('Red', windowName)
        image[:] = [blue, green, red]
        print("BGR:", blue, green, red)
         
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main() 

``` 

çıktı : 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/Screenshot-117.png" alt="Sample image" height = 200>
</p>  

Açıklama:

- np.zeros((512, 512, 3), np.uint8)
→ 512×512 boyutunda, 3 kanallı siyah bir görüntü oluşturur.

- cv2.namedWindow(windowName)
→ Renk paletini göstermek için bir pencere oluşturur.

- cv2.createTrackbar()
→ Mavi (Blue), Yeşil (Green) ve Kırmızı (Red) için 0–255 arası değer alan trackbar kaydırıcılarını ekler.

- cv2.getTrackbarPos()
→ Trackbarların o anki değerlerini okur.

- image[:] = [blue, green, red]
→ Trackbarlarla seçilen BGR değerlerini kullanarak görüntünün tamamını seçilen renkle doldurur.
Bu görüntü cv2.imshow() ile ekrana verilir.

- cv2.waitKey(1) == 27
→ ESC tuşuna basılınca döngüyü bitirir.

- cv2.destroyAllWindows()
→ Program kapanırken tüm pencereleri kapatır.

### Python OpenCV kullanarak dikdörtgen şekil çizme ve nesneleri çıkarma 

``` python 
import cv2
import numpy as np

drawing = False    
mode = True         
ix, iy = -1, -1

def draw_circle(event, x, y, flags, param):
    global ix, iy, drawing, mode
    
    if event == cv2.EVENT_LBUTTONDOWN:
        drawing = True
        ix, iy = x, y
    
    elif event == cv2.EVENT_MOUSEMOVE:
        if drawing == True:
            if mode == True:
                cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), 3)
                a = x
                b = y
                if a != x | b != y:
                    cv2.rectangle(img, (ix, iy), (x, y), (0, 0, 0), -1)
            else:
                cv2.circle(img, (x, y), 5, (0, 0, 255), -1)
    
    elif event == cv2.EVENT_LBUTTONUP:
        drawing = False
        if mode == True:
            cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), 2)
    
        else:
            cv2.circle(img, (x, y), 5, (0, 0, 255), -1)
    
img = np.zeros((512, 512, 3), np.uint8)
cv2.namedWindow('image')
cv2.setMouseCallback('image', draw_circle)

while(1):
    cv2.imshow('image', img)
    k = cv2.waitKey(1) & 0xFF
    if k == ord('m'):
        mode = not mode
    elif k == 27:
        break

cv2.destroyAllWindows()
``` 

çıktı: 

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/F2bAc-266x300.jpg" alt="Sample image" height = 200>
</p>   

Açıklama: 
Boş Bir Image Oluşturuluyor

``` python 
img = np.zeros((512, 512, 3), np.uint8)
``` 

- 512×512 piksel boyutunda siyah bir görüntü üretiyor.

- 3 kanal → BGR renk formatı.

- np.uint8 → her piksel 0–255 arasında değer alabiliyor.

Pencere Oluşturma ve Mouse Callback Bağlama 

``` python
cv2.namedWindow('image')
cv2.setMouseCallback('image', draw_circle)
``` 

- 'image' isminde bir pencere açıyor.

- Bu pencerede gerçekleşen her fare olayı, draw_circle fonksiyonuna gönderiliyor.

Fare Event’leri:

- ``EVENT_LBUTTONDOWN`` → Sol tık basıldı

- ``EVENT_MOUSEMOVE`` → Fare hareket ediyor

- ``EVENT_LBUTTONUP`` → Sol tık bırakıldı

Sol Tık Basıldığında (Başlangıç Noktası Seçimi):

``` python
if event == cv2.EVENT_LBUTTONDOWN:
    drawing = True
    ix, iy = x, y
``` 

- Kullanıcı sol tıkladığında, çizim modu aktif olur: drawing = True

- Tıkladığın nokta kaydedilir: (ix, iy)

Fare Hareket Ederken:

``` python
elif event == cv2.EVENT_MOUSEMOVE:
    if drawing == True:
``` 

Eğer tıklanıp fare hareket ettiriliyorsa çizim yapılır.

Dikdörtgen modu aktif (mode == True)`

``` python
cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), 3)
```

- Başlangıç noktası: (ix, iy)

- Güncel fare pozisyonu: (x, y)

- Renk: yeşil

- Kalınlık: 3 px

Daire modu (mode == False)

``` python
cv2.circle(img, (x, y), 5, (0, 0, 255), -1)
```

Fare hareket ederken sürekli 5 px yarıçaplı kırmızı noktalar çizerek fırça gibi davranır.

Sol Tık Bırakıldığında

``` python 
elif event == cv2.EVENT_LBUTTONUP:
    drawing = False
```

Tıklama bitmiştir, artık çizim sonlandırılır.

Dikdörtgen modundaysa:

``` python
cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), 2)
```

Daire modundaysa:

``` python
cv2.circle(img, (x, y), 5, (0, 0, 255), -1)
``` 

Sonsuz Döngü ve Klavye Kontrolleri

``` python
k = cv2.waitKey(1) & 0xFF
``` 

Her 1 ms’de bir klavyeyi kontrol eder.

m tuşuna basılırsa → Mod değişir

``` python
if k == ord('m'):
    mode = not mode
```

- Dikdörtgen ↔ Daire modu arasında geçiş sağlar.

ESC tuşu (27) → Çıkış

``` python
elif k == 27:
    break
``` 


Pencereyi Kapatma

``` python
cv2.destroyAllWindows()
``` 

Kısaca Kod Ne Yapıyor?

- Sol tık ile çizime başlıyorsun.

- Fareyi hareket ettirdikçe şekil oluşuyor.

- m tuşu → dikdörtgen ile daire modu arasında geçiş.

- ESC → çıkış. 